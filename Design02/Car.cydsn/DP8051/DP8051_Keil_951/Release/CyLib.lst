C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CYLIB
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Release\CyLib.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.1\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,.\Generated_Source\PSoC3) FF(3) DB WL(2) PR(
                    -.\DP8051\DP8051_Keil_951\Release/CyLib.lst) CD OT(8,SIZE) OJ(.\DP8051\DP8051_Keil_951\Release\CyLib.obj)

line level    source

*** MESSAGE C286 IN LINE 0 OF (null): license limits optimization to level 5
   1          /*******************************************************************************
   2          * File Name: CyLib.c
   3          * Version 4.20
   4          *
   5          *  Description:
   6          *   Provides a system API for the clocking, interrupts and watchdog timer.
   7          *
   8          *  Note:
   9          *   Documentation of the API's in this file is located in the
  10          *   System Reference Guide provided with PSoC Creator.
  11          *
  12          ********************************************************************************
  13          * Copyright 2008-2014, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions,
  15          * disclaimers, and limitations in the end user license agreement accompanying
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "CyLib.h"
  20          
  21          
  22          /*******************************************************************************
  23          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  24          * a device reset. It is set from initialize_psoc() at the early initialization
  25          * stage. In case of IAR EW IDE, initialize_psoc() is executed before the data
  26          * sections are initialized. To avoid zeroing, CyResetStatus should be placed
  27          * to the .noinit section.
  28          *******************************************************************************/
  29          CY_NOINIT uint8 CYXDATA CyResetStatus;
  30          
  31          
  32          /* Variable Vdda */
  33          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  38          
  39          
  40          /* Do not use these definitions directly in your application */
  41          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  42          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  43          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  44          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  45          
  46          
  47          /* Function Prototypes */
  48          static uint8 CyUSB_PowerOnCheck(void)  ;
  49          static void CyIMO_SetTrimValue(uint8 freq) ;
  50          static void CyBusClk_Internal_SetDivider(uint16 divider);
  51          
  52          #if(CY_PSOC5)
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 2   

                      static cySysTickCallback CySysTickCallbacks[CY_SYS_SYST_NUM_OF_CALLBACKS];
                  static void CySysTickServiceCallbacks(void);
                  uint32 CySysTickInitVar = 0u;
              #endif  /* (CY_PSOC5) */
  57          
  58          
  59          /*******************************************************************************
  60          * Function Name: CyPLL_OUT_Start
  61          ********************************************************************************
  62          *
  63          * Summary:
  64          *   Enables the PLL.  Optionally waits for it to become stable.
  65          *   Waits at least 250 us or until it is detected that the PLL is stable.
  66          *
  67          * Parameters:
  68          *   wait:
  69          *    0: Return immediately after configuration
  70          *    1: Wait for PLL lock or timeout.
  71          *
  72          * Return:
  73          *   Status
  74          *    CYRET_SUCCESS - Completed successfully
  75          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  76          *     If the input source of the clock is jittery, then the lock indication
  77          *     may not occur.  However, after the timeout has expired the generated PLL
  78          *     clock can still be used.
  79          *
  80          * Side Effects:
  81          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
  82          *  Any other use of the Fast Time Wheel will be stopped during the period of
  83          *  this function and then restored. This function also uses the 100 KHz ILO.
  84          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  85          *  this function.
  86          *
  87          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  88          *  Once Per Second interrupt may be made by interrupt routines during the period
  89          *  of this function execution. The current operation of the ILO, Central Time
  90          *  Wheel and Once Per Second interrupt are maintained during the operation of
  91          *  this function provided the reading of the Power Manager Interrupt Status
  92          *  Register is only done using the CyPmReadStatus() function.
  93          *
  94          *******************************************************************************/
  95          cystatus CyPLL_OUT_Start(uint8 wait) 
  96          {
  97   1          cystatus status = CYRET_SUCCESS;
  98   1      
  99   1          uint8 iloEnableState;
 100   1          uint8 pmTwCfg0State;
 101   1          uint8 pmTwCfg2State;
 102   1      
 103   1      
 104   1          /* Enables PLL circuit  */
 105   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 106   1      
 107   1          if(wait != 0u)
 108   1          {
 109   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
 110   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 111   2              pmTwCfg0State = CY_LIB_PM_TW_CFG0_REG;
 112   2              pmTwCfg2State = CY_LIB_PM_TW_CFG2_REG;
 113   2      
 114   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 3   

 115   2      
 116   2              status = CYRET_TIMEOUT;
 117   2      
 118   2              while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 119   2              {
 120   3                  /* Wait for interrupt status */
 121   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 122   3                  {
 123   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 124   4                      {
 125   5                          status = CYRET_SUCCESS;
 126   5                          break;
 127   5                      }
 128   4                  }
 129   3              }
 130   2      
 131   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 132   2              if(0u == iloEnableState)
 133   2              {
 134   3                  CyILO_Stop100K();
 135   3              }
 136   2      
 137   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0State;
 138   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2State;
 139   2          }
 140   1      
 141   1          return(status);
 142   1      }
 143          
 144          
 145          /*******************************************************************************
 146          * Function Name: CyPLL_OUT_Stop
 147          ********************************************************************************
 148          *
 149          * Summary:
 150          *  Disables the PLL.
 151          *
 152          * Parameters:
 153          *  None
 154          *
 155          * Return:
 156          *  None
 157          *
 158          *******************************************************************************/
 159          void CyPLL_OUT_Stop(void) 
 160          {
 161   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 162   1      }
 163          
 164          
 165          /*******************************************************************************
 166          * Function Name: CyPLL_OUT_SetPQ
 167          ********************************************************************************
 168          *
 169          * Summary:
 170          *  Sets the P and Q dividers and the charge pump current.
 171          *  The Frequency Out will be P/Q * Frequency In.
 172          *  The PLL must be disabled before calling this function.
 173          *
 174          * Parameters:
 175          *  uint8 pDiv:
 176          *   Valid range [8 - 255].
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 4   

 177          *
 178          *  uint8 qDiv:
 179          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 180          
 181          *  uint8 current:
 182          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 183          *   datasheet for more information.
 184          *
 185          * Return:
 186          *  None
 187          *
 188          * Side Effects:
 189          *  If this function execution results in the CPU clock frequency increasing,
 190          *  then the number of clock cycles the cache will wait before it samples data
 191          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 192          *  with an appropriate parameter. It can be optionally called if the CPU clock
 193          *  frequency is lowered in order to improve the CPU performance.
 194          *  See CyFlash_SetWaitCycles() description for more information.
 195          *
 196          *******************************************************************************/
 197          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 198          {
 199   1          /* Halt CPU in debug mode if PLL is enabled */
 200   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 201   1      
 202   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 203   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 204   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 205   1          {
 206   2              /* Set new values */
 207   2              CY_CLK_PLL_P_REG = pDiv;
 208   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 209   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 210   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 211   2          }
 212   1          else
 213   1          {
 214   2              /***********************************************************************
 215   2              * Halt CPU in debug mode if:
 216   2              * - P divider is less than required
 217   2              * - Q divider is out of range
 218   2              * - pump current is out of range
 219   2              ***********************************************************************/
 220   2              CYASSERT(0u != 0u);
 221   2          }
 222   1      
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: CyPLL_OUT_SetSource
 228          ********************************************************************************
 229          *
 230          * Summary:
 231          *  Sets the input clock source to the PLL. The PLL must be disabled before
 232          *  calling this function.
 233          *
 234          * Parameters:
 235          *   source: One of the three available PLL clock sources
 236          *    CY_PLL_SOURCE_IMO  :   IMO
 237          *    CY_PLL_SOURCE_XTAL :   MHz Crystal
 238          *    CY_PLL_SOURCE_DSI  :   DSI
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 5   

 239          *
 240          * Return:
 241          *  None
 242          *
 243          * Side Effects:
 244          *  If this function execution results in the CPU clock frequency increasing,
 245          *  then the number of clock cycles the cache will wait before it samples data
 246          *  coming back from the3 Flash must be adjusted by calling CyFlash_SetWaitCycles()
 247          *  with an appropriate parameter. It can be optionally called if the CPU clock
 248          *  frequency is lowered in order to improve the CPU performance.
 249          *  See CyFlash_SetWaitCycles() description for more information.
 250          *
 251          *******************************************************************************/
 252          void CyPLL_OUT_SetSource(uint8 source) 
 253          {
 254   1          /* Halt CPU in debug mode if PLL is enabled */
 255   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 256   1      
 257   1          switch(source)
 258   1          {
 259   2              case CY_PLL_SOURCE_IMO:
 260   2              case CY_PLL_SOURCE_XTAL:
 261   2              case CY_PLL_SOURCE_DSI:
 262   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 263   2              break;
 264   2      
 265   2              default:
 266   2                  CYASSERT(0u != 0u);
 267   2              break;
 268   2          }
 269   1      }
 270          
 271          
 272          /*******************************************************************************
 273          * Function Name: CyIMO_Start
 274          ********************************************************************************
 275          *
 276          * Summary:
 277          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 278          *
 279          * Parameters:
 280          *  uint8 wait:
 281          *   0: Return immediately after configuration
 282          *   1: Wait for at least 6 us for the IMO to settle.
 283          *
 284          * Return:
 285          *  None
 286          *
 287          * Side Effects:
 288          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
 289          *  Any other use of the Fast Time Wheel will be stopped during the period of
 290          *  this function and then restored. This function also uses the 100 KHz ILO.
 291          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 292          *  this function.
 293          *
 294          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 295          *  Once Per Second interrupt may be made by interrupt routines during the period
 296          *  of this function execution. The current operation of the ILO, Central Time
 297          *  Wheel and Once Per Second interrupt are maintained during the operation of
 298          *  this function provided the reading of the Power Manager Interrupt Status
 299          *  Register is only done using the CyPmReadStatus() function.
 300          *
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 6   

 301          *******************************************************************************/
 302          void CyIMO_Start(uint8 wait) 
 303          {
 304   1          uint8 pmFtwCfg2Reg;
 305   1          uint8 pmFtwCfg0Reg;
 306   1          uint8 ilo100KhzEnable;
 307   1      
 308   1      
 309   1          CY_LIB_PM_ACT_CFG0_REG  |= CY_LIB_PM_ACT_CFG0_IMO_EN;
 310   1          CY_LIB_PM_STBY_CFG0_REG |= CY_LIB_PM_STBY_CFG0_IMO_EN;
 311   1      
 312   1          if(0u != wait)
 313   1          {
 314   2              /* Need to turn on 100KHz ILO if it happens to not already be running.*/
 315   2              ilo100KhzEnable = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 316   2              pmFtwCfg0Reg = CY_LIB_PM_TW_CFG0_REG;
 317   2              pmFtwCfg2Reg = CY_LIB_PM_TW_CFG2_REG;
 318   2      
 319   2              CyPmFtwSetInterval(CY_LIB_CLK_IMO_FTW_TIMEOUT);
 320   2      
 321   2              while (0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 322   2              {
 323   3                  /* Wait for interrupt status */
 324   3              }
 325   2      
 326   2              if(0u == ilo100KhzEnable)
 327   2              {
 328   3                  CyILO_Stop100K();
 329   3              }
 330   2      
 331   2              CY_LIB_PM_TW_CFG0_REG = pmFtwCfg0Reg;
 332   2              CY_LIB_PM_TW_CFG2_REG = pmFtwCfg2Reg;
 333   2          }
 334   1      }
 335          
 336          
 337          /*******************************************************************************
 338          * Function Name: CyIMO_Stop
 339          ********************************************************************************
 340          *
 341          * Summary:
 342          *   Disables the IMO.
 343          *
 344          * Parameters:
 345          *  None
 346          *
 347          * Return:
 348          *  None
 349          *
 350          *******************************************************************************/
 351          void CyIMO_Stop(void) 
 352          {
 353   1          CY_LIB_PM_ACT_CFG0_REG  &= ((uint8) (~CY_LIB_PM_ACT_CFG0_IMO_EN));
 354   1          CY_LIB_PM_STBY_CFG0_REG &= ((uint8) (~CY_LIB_PM_STBY_CFG0_IMO_EN));
 355   1      }
 356          
 357          
 358          /*******************************************************************************
 359          * Function Name: CyUSB_PowerOnCheck
 360          ********************************************************************************
 361          *
 362          * Summary:
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 7   

 363          *  Returns the USB power status value. A private function to cy_boot.
 364          *
 365          * Parameters:
 366          *   None
 367          *
 368          * Return:
 369          *   uint8: one if the USB is enabled, 0 if not enabled.
 370          *
 371          *******************************************************************************/
 372          static uint8 CyUSB_PowerOnCheck(void)  
 373          {
 374   1          uint8 poweredOn = 0u;
 375   1      
 376   1          /* Check whether device is in Active or AltActiv and if USB is powered on */
 377   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 378   1             (0u != (CY_LIB_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 379   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 380   1             (0u != (CY_LIB_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 381   1          {
 382   2              poweredOn = 1u;
 383   2          }
 384   1      
 385   1          return (poweredOn);
 386   1      }
 387          
 388          
 389          /*******************************************************************************
 390          * Function Name: CyIMO_SetTrimValue
 391          ********************************************************************************
 392          *
 393          * Summary:
 394          *  Sets the IMO factory trim values.
 395          *
 396          * Parameters:
 397          *  uint8 freq - frequency for which trims must be set
 398          *
 399          * Return:
 400          *  None
 401          *
 402          *******************************************************************************/
 403          static void CyIMO_SetTrimValue(uint8 freq) 
 404          {
 405   1          uint8 usbPowerOn = CyUSB_PowerOnCheck();
 406   1      
 407   1          /* If USB is powered */
 408   1          if(usbPowerOn == 1u)
 409   1          {
 410   2              /* Unlock USB write */
 411   2              CY_LIB_USB_CR1_REG &= ((uint8)(~CY_LIB_USB_CLK_EN));
 412   2          }
 413   1          switch(freq)
 414   1          {
 415   2          case CY_IMO_FREQ_3MHZ:
 416   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_3MHZ_PTR);
 417   2              break;
 418   2      
 419   2          case CY_IMO_FREQ_6MHZ:
 420   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_6MHZ_PTR);
 421   2              break;
 422   2      
 423   2          case CY_IMO_FREQ_12MHZ:
 424   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_12MHZ_PTR);
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 8   

 425   2              break;
 426   2      
 427   2          case CY_IMO_FREQ_24MHZ:
 428   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_24MHZ_PTR);
 429   2              break;
 430   2      
 431   2          case CY_IMO_FREQ_48MHZ:
 432   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_TR1_PTR);
 433   2              break;
 434   2      
 435   2          case CY_IMO_FREQ_62MHZ:
 436   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_67MHZ_PTR);
 437   2              break;
 438   2      
 439   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_80MHZ_PTR);
                      break;
              #endif  /* (CY_PSOC5) */
 444   2      
 445   2          case CY_IMO_FREQ_USB:
 446   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_USB_PTR);
 447   2      
 448   2              /* If USB is powered */
 449   2              if(usbPowerOn == 1u)
 450   2              {
 451   3                  /* Lock USB Oscillator */
 452   3                  CY_LIB_USB_CR1_REG |= CY_LIB_USB_CLK_EN;
 453   3              }
 454   2              break;
 455   2      
 456   2          default:
 457   2                  CYASSERT(0u != 0u);
 458   2              break;
 459   2          }
 460   1      
 461   1      }
 462          
 463          
 464          /*******************************************************************************
 465          * Function Name: CyIMO_SetFreq
 466          ********************************************************************************
 467          *
 468          * Summary:
 469          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 470          *
 471          * Parameters:
 472          *  freq: Frequency of IMO operation
 473          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
 474          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
 475          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 476          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 477          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 478          *       CY_IMO_FREQ_62MHZ to set 62.6 MHz
 479          *       CY_IMO_FREQ_74MHZ to set 74.7 MHz (not applicable for PSoC 3)
 480          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 481          *
 482          * Return:
 483          *  None
 484          *
 485          * Side Effects:
 486          *  If this function execution results in the CPU clock frequency increasing,
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 9   

 487          *  then the number of clock cycles the cache will wait before it samples data
 488          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 489          *  with an appropriate parameter. It can be optionally called if the CPU clock
 490          *  frequency is lowered in order to improve the CPU performance.
 491          *  See CyFlash_SetWaitCycles() description for more information.
 492          *
 493          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 494          *  Otherwise this circuit is disabled. The USB block must be powered before
 495          *  selecting the USB setting.
 496          *
 497          *******************************************************************************/
 498          void CyIMO_SetFreq(uint8 freq) 
 499          {
 500   1          uint8 currentFreq;
 501   1          uint8 nextFreq;
 502   1      
 503   1          /***************************************************************************
 504   1          * If the IMO frequency is changed,the Trim values must also be set
 505   1          * accordingly.This requires reading the current frequency. If the new
 506   1          * frequency is faster, then set a new trim and then change the frequency,
 507   1          * otherwise change the frequency and then set new trim values.
 508   1          ***************************************************************************/
 509   1      
 510   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 511   1      
 512   1          /* Check if requested frequency is USB. */
 513   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 514   1      
 515   1          switch (currentFreq)
 516   1          {
 517   2          case 0u:
 518   2              currentFreq = CY_IMO_FREQ_12MHZ;
 519   2              break;
 520   2      
 521   2          case 1u:
 522   2              currentFreq = CY_IMO_FREQ_6MHZ;
 523   2              break;
 524   2      
 525   2          case 2u:
 526   2              currentFreq = CY_IMO_FREQ_24MHZ;
 527   2              break;
 528   2      
 529   2          case 3u:
 530   2              currentFreq = CY_IMO_FREQ_3MHZ;
 531   2              break;
 532   2      
 533   2          case 4u:
 534   2              currentFreq = CY_IMO_FREQ_48MHZ;
 535   2              break;
 536   2      
 537   2          case 5u:
 538   2              currentFreq = CY_IMO_FREQ_62MHZ;
 539   2              break;
 540   2      
 541   2      #if(CY_PSOC5)
                  case 6u:
                      currentFreq = CY_IMO_FREQ_74MHZ;
                      break;
              #endif  /* (CY_PSOC5) */
 546   2      
 547   2          default:
 548   2              CYASSERT(0u != 0u);
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 10  

 549   2              break;
 550   2          }
 551   1      
 552   1          if (nextFreq >= currentFreq)
 553   1          {
 554   2              /* Set new trim first */
 555   2              CyIMO_SetTrimValue(freq);
 556   2          }
 557   1      
 558   1          /* Set usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 559   1          switch(freq)
 560   1          {
 561   2          case CY_IMO_FREQ_3MHZ:
 562   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 563   2                  CY_LIB_IMO_3MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 564   2              break;
 565   2      
 566   2          case CY_IMO_FREQ_6MHZ:
 567   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 568   2                  CY_LIB_IMO_6MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 569   2              break;
 570   2      
 571   2          case CY_IMO_FREQ_12MHZ:
 572   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 573   2                  CY_LIB_IMO_12MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 574   2              break;
 575   2      
 576   2          case CY_IMO_FREQ_24MHZ:
 577   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 578   2                  CY_LIB_IMO_24MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 579   2              break;
 580   2      
 581   2          case CY_IMO_FREQ_48MHZ:
 582   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 583   2                  CY_LIB_IMO_48MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 584   2              break;
 585   2      
 586   2          case CY_IMO_FREQ_62MHZ:
 587   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 588   2                  CY_LIB_IMO_62MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 589   2              break;
 590   2      
 591   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
                          CY_LIB_IMO_74MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
                      break;
              #endif  /* (CY_PSOC5) */
 597   2      
 598   2          case CY_IMO_FREQ_USB:
 599   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 600   2                  CY_LIB_IMO_24MHZ_VALUE) | CY_LIB_IMO_USBCLK_ON_SET;
 601   2              break;
 602   2      
 603   2          default:
 604   2              CYASSERT(0u != 0u);
 605   2              break;
 606   2          }
 607   1      
 608   1          /* Tu rn onIMO Doubler, if switching to CY_IMO_FREQ_USB */
 609   1          if (freq == CY_IMO_FREQ_USB)
 610   1          {
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 11  

 611   2              CyIMO_EnableDoubler();
 612   2          }
 613   1          else
 614   1          {
 615   2              CyIMO_DisableDoubler();
 616   2          }
 617   1      
 618   1          if (nextFreq < currentFreq)
 619   1          {
 620   2              /* Set the trim after setting frequency */
 621   2              CyIMO_SetTrimValue(freq);
 622   2          }
 623   1      }
 624          
 625          
 626          /*******************************************************************************
 627          * Function Name: CyIMO_SetSource
 628          ********************************************************************************
 629          *
 630          * Summary:
 631          *  Sets the source of the clock output from the IMO block.
 632          *
 633          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 634          *  Crystal or DSI input can be the source of the IMO output instead.
 635          *
 636          * Parameters:
 637          *   source: CY_IMO_SOURCE_DSI to set the DSI as source.
 638          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 639          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 640          *
 641          * Return:
 642          *  None
 643          *
 644          * Side Effects:
 645          *  If this function execution resulted in the CPU clock frequency increasing,
 646          *  then the number of clock cycles the cache will wait before it samples data
 647          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 648          *  with an appropriate parameter. It can be optionally called if the CPU clock
 649          *  frequency is lowered in order to improve the CPU performance.
 650          *  See CyFlash_SetWaitCycles() description for more information.
 651          *
 652          *******************************************************************************/
 653          void CyIMO_SetSource(uint8 source) 
 654          {
 655   1          switch(source)
 656   1          {
 657   2          case CY_IMO_SOURCE_DSI:
 658   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 659   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 660   2              break;
 661   2      
 662   2          case CY_IMO_SOURCE_XTAL:
 663   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
 664   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 665   2              break;
 666   2      
 667   2          case CY_IMO_SOURCE_IMO:
 668   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
 669   2              break;
 670   2      
 671   2          default:
 672   2              /* Incorrect source value */
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 12  

 673   2              CYASSERT(0u != 0u);
 674   2              break;
 675   2          }
 676   1      }
 677          
 678          
 679          /*******************************************************************************
 680          * Function Name: CyIMO_EnableDoubler
 681          ********************************************************************************
 682          *
 683          * Summary:
 684          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 685          *  input to a 48 MHz output for use by the USB block.
 686          *
 687          * Parameters:
 688          *  None
 689          *
 690          * Return:
 691          *  None
 692          *
 693          *******************************************************************************/
 694          void CyIMO_EnableDoubler(void) 
 695          {
 696   1          /* Set FASTCLK_IMO_CR_PTR regigster's 4th bit */
 697   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 698   1      }
 699          
 700          
 701          /*******************************************************************************
 702          * Function Name: CyIMO_DisableDoubler
 703          ********************************************************************************
 704          *
 705          * Summary:
 706          *   Disables the IMO doubler.
 707          *
 708          * Parameters:
 709          *  None
 710          *
 711          * Return:
 712          *  None
 713          *
 714          *******************************************************************************/
 715          void CyIMO_DisableDoubler(void) 
 716          {
 717   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: CyMasterClk_SetSource
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  Sets the source of the master clock.
 727          *
 728          * Parameters:
 729          *   source: One of the four available Master clock sources.
 730          *     CY_MASTER_SOURCE_IMO
 731          *     CY_MASTER_SOURCE_PLL
 732          *     CY_MASTER_SOURCE_XTAL
 733          *     CY_MASTER_SOURCE_DSI
 734          *
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 13  

 735          * Return:
 736          *  None
 737          *
 738          * Side Effects:
 739          *  The current source and the new source must both be running and stable before
 740          *  calling this function.
 741          *
 742          *  If this function execution resulted in the CPU clock frequency increasing,
 743          *  then the number of clock cycles the cache will wait before it samples data
 744          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 745          *  with an appropriate parameter. It can be optionally called if the CPU clock
 746          *  frequency is lowered in order to improve the CPU performance.
 747          *  See CyFlash_SetWaitCycles() description for more information.
 748          *
 749          *******************************************************************************/
 750          void CyMasterClk_SetSource(uint8 source) 
 751          {
 752   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 753   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 754   1      }
 755          
 756          
 757          /*******************************************************************************
 758          * Function Name: CyMasterClk_SetDivider
 759          ********************************************************************************
 760          *
 761          * Summary:
 762          *  Sets the divider value used to generate Master Clock.
 763          *
 764          * Parameters:
 765          *  uint8 divider:
 766          *   The valid range is [0-255]. The clock will be divided by this value + 1.
 767          *   For example to divide this parameter by two should be set to 1.
 768          *
 769          * Return:
 770          *  None
 771          *
 772          * Side Effects:
 773          *  If this function execution resulted in the CPU clock frequency increasing,
 774          *  then the number of clock cycles the cache will wait before it samples data
 775          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 776          *  with an appropriate parameter. It can be optionally called if the CPU clock
 777          *  frequency is lowered in order to improve the CPU performance.
 778          *  See CyFlash_SetWaitCycles() description for more information.
 779          *
 780          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 781          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 782          *  than the final/expected div-by-1 period.
 783          *
 784          *******************************************************************************/
 785          void CyMasterClk_SetDivider(uint8 divider) 
 786          {
 787   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 788   1      }
 789          
 790          
 791          /*******************************************************************************
 792          * Function Name: CyBusClk_Internal_SetDivider
 793          ********************************************************************************
 794          *
 795          * Summary:
 796          *  The function used by CyBusClk_SetDivider(). For internal use only.
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 14  

 797          *
 798          * Parameters:
 799          *   divider: Valid range [0-65535].
 800          *   The clock will be divided by this value + 1.
 801          *   For example, to divide this parameter by two should be set to 1.
 802          *
 803          * Return:
 804          *  None
 805          *
 806          *******************************************************************************/
 807          static void CyBusClk_Internal_SetDivider(uint16 divider)
 808          {
 809   1          /* Mask bits to enable shadow loads  */
 810   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
 811   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 812   1      
 813   1          /* Enable mask bits to enable shadow loads */
 814   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 815   1      
 816   1          /* Update Shadow Divider Value Register with new divider */
 817   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 818   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 819   1      
 820   1      
 821   1          /***************************************************************************
 822   1          * Copy shadow value defined in Shadow Divider Value Register
 823   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 824   1          * dividers selected in Analog and Digital Clock Mask Registers
 825   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
 826   1          ***************************************************************************/
 827   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 828   1      }
 829          
 830          
 831          /*******************************************************************************
 832          * Function Name: CyBusClk_SetDivider
 833          ********************************************************************************
 834          *
 835          * Summary:
 836          *  Sets the divider value used to generate the Bus Clock.
 837          *
 838          * Parameters:
 839          *  divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 840          *  For example, to divide this parameter by two should be set to 1.
 841          *
 842          * Return:
 843          *  None
 844          *
 845          * Side Effects:
 846          *  If this function execution resulted in the CPU clock frequency increasing,
 847          *  then the number of clock cycles the cache will wait before it samples data
 848          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 849          *  with an appropriate parameter. It can be optionally called if the CPU clock
 850          *  frequency is lowered in order to improve the CPU performance.
 851          *  See CyFlash_SetWaitCycles() description for more information.
 852          *
 853          *******************************************************************************/
 854          void CyBusClk_SetDivider(uint16 divider) 
 855          {
 856   1          uint8  masterClkDiv;
 857   1          uint16 busClkDiv;
 858   1          uint8 interruptState;
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 15  

 859   1      
 860   1          interruptState = CyEnterCriticalSection();
 861   1      
 862   1          /* Work around to set bus clock divider value */
 863   1          busClkDiv = (uint16)((uint16)CY_LIB_CLKDIST_BCFG_MSB_REG << 8u);
 864   1          busClkDiv |= CY_LIB_CLKDIST_BCFG_LSB_REG;
 865   1      
 866   1          if ((divider == 0u) || (busClkDiv == 0u))
 867   1          {
 868   2              /* Save away master clock divider value */
 869   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 870   2      
 871   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 872   2              {
 873   3                  /* Set master clock divider to 7 */
 874   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 875   3              }
 876   2      
 877   2              if (divider == 0u)
 878   2              {
 879   3                  /* Set SSS bit and divider register desired value */
 880   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 881   3                  CyBusClk_Internal_SetDivider(divider);
 882   3              }
 883   2              else
 884   2              {
 885   3                  CyBusClk_Internal_SetDivider(divider);
 886   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 887   3              }
 888   2      
 889   2              /* Restore master clock */
 890   2              CyMasterClk_SetDivider(masterClkDiv);
 891   2          }
 892   1          else
 893   1          {
 894   2              CyBusClk_Internal_SetDivider(divider);
 895   2          }
 896   1      
 897   1          CyExitCriticalSection(interruptState);
 898   1      }
 899          
 900          
 901          #if(CY_PSOC3)
 902          
 903              /*******************************************************************************
 904              * Function Name: CyCpuClk_SetDivider
 905              ********************************************************************************
 906              *
 907              * Summary:
 908              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 909              *  PSoC 3 parts.
 910              *
 911              * Parameters:
 912              *  divider: Valid range [0-15]. The clock will be divided by this value + 1.
 913              *  For example, to divide this parameter by two should be set to 1.
 914              *
 915              * Return:
 916              *  None
 917              *
 918              * Side Effects:
 919              *  If this function execution resulted in the CPU clock frequency increasing,
 920          *  then the number of clock cycles the cache will wait before it samples data
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 16  

 921          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 922          *  with an appropriate parameter. It can be optionally called if the CPU clock
 923          *  frequency is lowered in order to improve the CPU performance.
 924              *  See CyFlash_SetWaitCycles() description for more information.
 925              *
 926              *******************************************************************************/
 927              void CyCpuClk_SetDivider(uint8 divider) 
 928              {
 929   1                  CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & CY_LIB_CLKDIST_MSTR1_DIV_MASK) |
 930   1                                      ((uint8)(divider << CY_LIB_CLKDIST_DIV_POSITION));
 931   1          }
 932          
 933          #endif /* (CY_PSOC3) */
 934          
 935          
 936          /*******************************************************************************
 937          * Function Name: CyUsbClk_SetSource
 938          ********************************************************************************
 939          *
 940          * Summary:
 941          *  Sets the source of the USB clock.
 942          *
 943          * Parameters:
 944          *  source: One of the four available USB clock sources
 945          *    CY_LIB_USB_CLK_IMO2X     - IMO 2x
 946          *    CY_LIB_USB_CLK_IMO       - IMO
 947          *    CY_LIB_USB_CLK_PLL       - PLL
 948          *    CY_LIB_USB_CLK_DSI       - DSI
 949          *
 950          * Return:
 951          *  None
 952          *
 953          *******************************************************************************/
 954          void CyUsbClk_SetSource(uint8 source) 
 955          {
 956   1          CY_LIB_CLKDIST_UCFG_REG = (CY_LIB_CLKDIST_UCFG_REG & ((uint8)(~CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK))) |
 957   1                              (CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK & source);
 958   1      }
 959          
 960          
 961          /*******************************************************************************
 962          * Function Name: CyILO_Start1K
 963          ********************************************************************************
 964          *
 965          * Summary:
 966          *  Enables the ILO 1 KHz oscillator.
 967          *
 968          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
 969          *  selection in the Clock Editor. Therefore, this API is only needed if the
 970          *  oscillator was turned off manually.
 971          *
 972          * Parameters:
 973          *  None
 974          *
 975          * Return:
 976          *  None
 977          *
 978          *******************************************************************************/
 979          void CyILO_Start1K(void) 
 980          {
 981   1          /* Set bit 1 of ILO RS */
 982   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ;
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 17  

 983   1      }
 984          
 985          
 986          /*******************************************************************************
 987          * Function Name: CyILO_Stop1K
 988          ********************************************************************************
 989          *
 990          * Summary:
 991          *  Disables the ILO 1 KHz oscillator.
 992          *
 993          *  Note The ILO 1 KHz oscillator must be enabled if the Sleep or Hibernate low power
 994          *  mode APIs are expected to be used. For more information, refer to the Power
 995          *  Management section of this document.
 996          *
 997          * Parameters:
 998          *  None
 999          *
1000          * Return:
1001          *  None
1002          *
1003          * Side Effects:
1004          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
1005          *
1006          *******************************************************************************/
1007          void CyILO_Stop1K(void) 
1008          {
1009   1          /* Clear bit 1 of ILO RS */
1010   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ));
1011   1      }
1012          
1013          
1014          /*******************************************************************************
1015          * Function Name: CyILO_Start100K
1016          ********************************************************************************
1017          *
1018          * Summary:
1019          *  Enables the ILO 100 KHz oscillator.
1020          *
1021          * Parameters:
1022          *  None
1023          *
1024          * Return:
1025          *  None
1026          *
1027          *******************************************************************************/
1028          void CyILO_Start100K(void) 
1029          {
1030   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
1031   1      }
1032          
1033          
1034          /*******************************************************************************
1035          * Function Name: CyILO_Stop100K
1036          ********************************************************************************
1037          *
1038          * Summary:
1039          *  Disables the ILO 100 KHz oscillator.
1040          *
1041          * Parameters:
1042          *  None
1043          *
1044          * Return:
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 18  

1045          *  None
1046          *
1047          *******************************************************************************/
1048          void CyILO_Stop100K(void) 
1049          {
1050   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ));
1051   1      }
1052          
1053          
1054          /*******************************************************************************
1055          * Function Name: CyILO_Enable33K
1056          ********************************************************************************
1057          *
1058          * Summary:
1059          *  Enables the ILO 33 KHz divider.
1060          *
1061          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
1062          *  so it must also be running in order to generate the 33 KHz output.
1063          *
1064          * Parameters:
1065          *  None
1066          *
1067          * Return:
1068          *  None
1069          *
1070          *******************************************************************************/
1071          void CyILO_Enable33K(void) 
1072          {
1073   1          /* Set bit 5 of ILO RS */
1074   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ;
1075   1      }
1076          
1077          
1078          /*******************************************************************************
1079          * Function Name: CyILO_Disable33K
1080          ********************************************************************************
1081          *
1082          * Summary:
1083          *  Disables the ILO 33 KHz divider.
1084          *
1085          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
1086          *  API does not disable the 100 KHz clock.
1087          *
1088          * Parameters:
1089          *  None
1090          *
1091          * Return:
1092          *  None
1093          *
1094          *******************************************************************************/
1095          void CyILO_Disable33K(void) 
1096          {
1097   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ));
1098   1      }
1099          
1100          
1101          /*******************************************************************************
1102          * Function Name: CyILO_SetSource
1103          ********************************************************************************
1104          *
1105          * Summary:
1106          *  Sets the source of the clock output from the ILO block.
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 19  

1107          *
1108          * Parameters:
1109          *  source: One of the three available ILO output sources
1110          *       Value        Define                Source
1111          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
1112          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
1113          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
1114          *
1115          * Return:
1116          *  None
1117          *
1118          *******************************************************************************/
1119          void CyILO_SetSource(uint8 source) 
1120          {
1121   1          CY_LIB_CLKDIST_CR_REG = (CY_LIB_CLKDIST_CR_REG & CY_ILO_SOURCE_BITS_CLEAR) |
1122   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
1123   1      }
1124          
1125          
1126          /*******************************************************************************
1127          * Function Name: CyILO_SetPowerMode
1128          ********************************************************************************
1129          *
1130          * Summary:
1131          *  Sets the power mode used by the ILO during power down. Allows for lower power
1132          *  down power usage resulting in a slower startup time.
1133          *
1134          * Parameters:
1135          *  uint8 mode
1136          *   CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
1137          *   CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
1138          *
1139          * Return:
1140          *   Prevous power mode state.
1141          *
1142          *******************************************************************************/
1143          uint8 CyILO_SetPowerMode(uint8 mode) 
1144          {
1145   1          uint8 state;
1146   1      
1147   1          /* Get current state. */
1148   1          state = CY_LIB_SLOWCLK_ILO_CR0_REG;
1149   1      
1150   1          /* Set the oscillator power mode. */
1151   1          if(mode != CY_ILO_FAST_START)
1152   1          {
1153   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state | CY_ILO_CONTROL_PD_MODE);
1154   2          }
1155   1          else
1156   1          {
1157   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state & ((uint8)(~CY_ILO_CONTROL_PD_MODE)));
1158   2          }
1159   1      
1160   1          /* Return old mode. */
1161   1          return ((state & CY_ILO_CONTROL_PD_MODE) >> CY_ILO_CONTROL_PD_POSITION);
1162   1      }
1163          
1164          
1165          /*******************************************************************************
1166          * Function Name: CyXTAL_32KHZ_Start
1167          ********************************************************************************
1168          *
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 20  

1169          * Summary:
1170          *  Enables the 32 KHz Crystal Oscillator.
1171          *
1172          * Parameters:
1173          *  None
1174          *
1175          * Return:
1176          *  None
1177          *
1178          *******************************************************************************/
1179          void CyXTAL_32KHZ_Start(void) 
1180          {
1181   1          volatile uint16 i;
1182   1      
1183   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1184   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1185   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1186   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1187   1      
1188   1          #if(CY_PSOC3)
1189   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1190   1          #endif  /* (CY_PSOC3) */
1191   1      
1192   1          /* Enable operation of 32K Crystal Oscillator */
1193   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1194   1      
1195   1          for (i = 1000u; i > 0u; i--)
1196   1          {
1197   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1198   2              {
1199   3                  /* Ready - switch to high power mode */
1200   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1201   3      
1202   3                  break;
1203   3              }
1204   2              CyDelayUs(1u);
1205   2          }
1206   1      }
1207          
1208          
1209          /*******************************************************************************
1210          * Function Name: CyXTAL_32KHZ_Stop
1211          ********************************************************************************
1212          *
1213          * Summary:
1214          *  Disables the 32KHz Crystal Oscillator.
1215          *
1216          * Parameters:
1217          *  None
1218          *
1219          * Return:
1220          *  None
1221          *
1222          *******************************************************************************/
1223          void CyXTAL_32KHZ_Stop(void) 
1224          {
1225   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
1226   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
1227   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1228   1                                   CY_CLK_XTAL32_CFG_LP_DEFAULT;
1229   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1230   1      
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 21  

1231   1          #if(CY_PSOC3)
1232   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1233   1          #endif  /* (CY_PSOC3) */
1234   1      }
1235          
1236          
1237          /*******************************************************************************
1238          * Function Name: CyXTAL_32KHZ_ReadStatus
1239          ********************************************************************************
1240          *
1241          * Summary:
1242          *  Returns status of the 32 KHz oscillator.
1243          *
1244          * Parameters:
1245          *  None
1246          *
1247          * Return:
1248          *  Value     Define                    Source
1249          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1250          *                                       1: Stable
1251          *                                       0: Not stable
1252          *
1253          *******************************************************************************/
1254          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1255          {
1256   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
1257   1      }
1258          
1259          
1260          /*******************************************************************************
1261          * Function Name: CyXTAL_32KHZ_SetPowerMode
1262          ********************************************************************************
1263          *
1264          * Summary:
1265          *  Sets the power mode for the 32 KHz oscillator used during the sleep mode.
1266          *  Allows for lower power during sleep when there are fewer sources of noise.
1267          *  During the active mode the oscillator is always run in the high power mode.
1268          *
1269          * Parameters:
1270          *  uint8 mode
1271          *       0: High power mode
1272          *       1: Low power mode during sleep
1273          *
1274          * Return:
1275          *  Previous power mode.
1276          *
1277          *******************************************************************************/
1278          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1279          {
1280   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1281   1      
1282   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1283   1      
1284   1          if(1u == mode)
1285   1          {
1286   2              /* Low power mode during Sleep */
1287   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
1288   2              CyDelayUs(10u);
1289   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1290   2                                      CY_CLK_XTAL32_CFG_LP_LOWPOWER;
1291   2              CyDelayUs(20u);
1292   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 22  

1293   2          }
1294   1          else
1295   1          {
1296   2              /* High power mode */
1297   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1298   2              CyDelayUs(10u);
1299   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1300   2                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1301   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1302   2          }
1303   1      
1304   1          return(state);
1305   1      }
1306          
1307          
1308          /*******************************************************************************
1309          * Function Name: CyXTAL_Start
1310          ********************************************************************************
1311          *
1312          * Summary:
1313          *  Enables the megahertz crystal.
1314          *
1315          *  PSoC 3:
1316          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1317          *  number of milliseconds specified by the wait parameter has expired.
1318          *
1319          * Parameters:
1320          *   wait: Valid range [0-255].
1321          *   This is the timeout value in milliseconds.
1322          *   The appropriate value is crystal specific.
1323          *
1324          * Return:
1325          *   CYRET_SUCCESS - Completed successfully
1326          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1327          *
1328          * Side Effects and Restrictions:
1329          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1330          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
1331          *  of this function and then restored.
1332          *
1333          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1334          *  ILO for the period of this function. No changes to the setup of the ILO,
1335          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1336          *  by interrupt routines during the period of this function.
1337          *
1338          *  The current operation of the ILO, Central Timewheel and Once Per Second
1339          *  interrupt are maintained during the operation of this function provided the
1340          *  reading of the Power Manager Interrupt Status Register is only done using the
1341          *  CyPmReadStatus() function.
1342          *
1343          *******************************************************************************/
1344          cystatus CyXTAL_Start(uint8 wait) 
1345          {
1346   1          cystatus status = CYRET_SUCCESS;
1347   1          volatile uint8  timeout = wait;
1348   1          volatile uint8 count;
1349   1          uint8 iloEnableState;
1350   1          uint8 pmTwCfg0Tmp;
1351   1          uint8 pmTwCfg2Tmp;
1352   1      
1353   1      
1354   1          /* Enables MHz crystal oscillator circuit  */
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 23  

1355   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
1356   1      
1357   1      
1358   1          if(wait > 0u)
1359   1          {
1360   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1361   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG;
1362   2              pmTwCfg0Tmp = CY_LIB_PM_TW_CFG0_REG;
1363   2              pmTwCfg2Tmp = CY_LIB_PM_TW_CFG2_REG;
1364   2      
1365   2              /* Set 250 us interval */
1366   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1367   2              status = CYRET_TIMEOUT;
1368   2      
1369   2      
1370   2              for( ; timeout > 0u; timeout--)
1371   2              {
1372   3                  /* Read XERR bit to clear it */
1373   3                  (void) CY_CLK_XMHZ_CSR_REG;
1374   3      
1375   3                  /* Wait for 1 millisecond - 4 x 250 us */
1376   3                  for(count = 4u; count > 0u; count--)
1377   3                  {
1378   4                      while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
1379   4                      {
1380   5                          /* Wait for FTW interrupt event */
1381   5                      }
1382   4                  }
1383   3      
1384   3      
1385   3                  /*******************************************************************
1386   3                  * High output indicates an oscillator failure.
1387   3                  * Only can be used after a start-up interval (1 ms) is completed.
1388   3                  *******************************************************************/
1389   3                  if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1390   3                  {
1391   4                      status = CYRET_SUCCESS;
1392   4                      break;
1393   4                  }
1394   3              }
1395   2      
1396   2      
1397   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1398   2              if(0u == (iloEnableState & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ))
1399   2              {
1400   3                  CyILO_Stop100K();
1401   3              }
1402   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1403   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1404   2          }
1405   1      
1406   1          return(status);
1407   1      }
1408          
1409          
1410          /*******************************************************************************
1411          * Function Name: CyXTAL_Stop
1412          ********************************************************************************
1413          *
1414          * Summary:
1415          *  Disables the megahertz crystal oscillator.
1416          *
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 24  

1417          * Parameters:
1418          *  None
1419          *
1420          * Return:
1421          *  None
1422          *
1423          *******************************************************************************/
1424          void CyXTAL_Stop(void) 
1425          {
1426   1          /* Disable oscillator. */
1427   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1428   1      }
1429          
1430          
1431          /*******************************************************************************
1432          * Function Name: CyXTAL_EnableErrStatus
1433          ********************************************************************************
1434          *
1435          * Summary:
1436          *  Enables the generation of the XERR status bit for the megahertz crystal.
1437          *  This function is not available for PSoC5.
1438          *
1439          * Parameters:
1440          *  None
1441          *
1442          * Return:
1443          *  None
1444          *
1445          *******************************************************************************/
1446          void CyXTAL_EnableErrStatus(void) 
1447          {
1448   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1449   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1450   1      }
1451          
1452          
1453          /*******************************************************************************
1454          * Function Name: CyXTAL_DisableErrStatus
1455          ********************************************************************************
1456          *
1457          * Summary:
1458          *  Disables the generation of the XERR status bit for the megahertz crystal.
1459          *  This function is not available for PSoC5.
1460          *
1461          * Parameters:
1462          *  None
1463          *
1464          * Return:
1465          *  None
1466          *
1467          *******************************************************************************/
1468          void CyXTAL_DisableErrStatus(void) 
1469          {
1470   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1471   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1472   1      }
1473          
1474          
1475          /*******************************************************************************
1476          * Function Name: CyXTAL_ReadStatus
1477          ********************************************************************************
1478          *
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 25  

1479          * Summary:
1480          *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1481          *  sticky, clear on read. This function is not available for PSoC5.
1482          *
1483          * Parameters:
1484          *  None
1485          *
1486          * Return:
1487          *   Status
1488          *    0: No error
1489          *    1: Error
1490          *
1491          *******************************************************************************/
1492          uint8 CyXTAL_ReadStatus(void) 
1493          {
1494   1          /***************************************************************************
1495   1          * High output indicates an oscillator failure. Only use this after a start-up
1496   1          * interval is completed. This can be used for the status and failure recovery.
1497   1          ***************************************************************************/
1498   1          return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1499   1      }
1500          
1501          
1502          /*******************************************************************************
1503          * Function Name: CyXTAL_EnableFaultRecovery
1504          ********************************************************************************
1505          *
1506          * Summary:
1507          *  Enables the fault recovery circuit which will switch to the IMO in the case
1508          *  of a fault in the megahertz crystal circuit. The crystal must be up and
1509          *  running with the XERR bit at 0, before calling this function to prevent
1510          *  an immediate fault switchover. This function is not available for PSoC5.
1511          *
1512          * Parameters:
1513          *  None
1514          *
1515          * Return:
1516          *  None
1517          *
1518          *******************************************************************************/
1519          void CyXTAL_EnableFaultRecovery(void) 
1520          {
1521   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1522   1      }
1523          
1524          
1525          /*******************************************************************************
1526          * Function Name: CyXTAL_DisableFaultRecovery
1527          ********************************************************************************
1528          *
1529          * Summary:
1530          *  Disables the fault recovery circuit which will switch to the IMO in the case
1531          *  of a fault in the megahertz crystal circuit. This function is not available
1532          *  for PSoC5.
1533          *
1534          * Parameters:
1535          *  None
1536          *
1537          * Return:
1538          *  None
1539          *
1540          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 26  

1541          void CyXTAL_DisableFaultRecovery(void) 
1542          {
1543   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1544   1      }
1545          
1546          
1547          /*******************************************************************************
1548          * Function Name: CyXTAL_SetStartup
1549          ********************************************************************************
1550          *
1551          * Summary:
1552          *  Sets the startup settings for the crystal. The logic model outputs a frequency
1553          *  (setting + 4) MHz when enabled.
1554          *
1555          *  This is artificial as the actual frequency is determined by an attached
1556          *  external crystal.
1557          *
1558          * Parameters:
1559          *  setting: Valid range [0-31].
1560          *   The value is dependent on the frequency and quality of the crystal being used.
1561          *   Refer to the device TRM and datasheet for more information.
1562          *
1563          * Return:
1564          *  None
1565          *
1566          *******************************************************************************/
1567          void CyXTAL_SetStartup(uint8 setting) 
1568          {
1569   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1570   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1571   1      }
1572          
1573          
1574          
1575          /*******************************************************************************
1576          * Function Name: CyXTAL_SetFbVoltage
1577          ********************************************************************************
1578          *
1579          * Summary:
1580          *  Sets the feedback reference voltage to use for the crystal circuit.
1581          *  This function is only available for PSoC3 and PSoC 5LP.
1582          *
1583          * Parameters:
1584          *  setting: Valid range [0-15].
1585          *  Refer to the device TRM and datasheet for more information.
1586          *
1587          * Return:
1588          *  None
1589          *
1590          *******************************************************************************/
1591          void CyXTAL_SetFbVoltage(uint8 setting) 
1592          {
1593   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1594   1                                  (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1595   1      }
1596          
1597          
1598          /*******************************************************************************
1599          * Function Name: CyXTAL_SetWdVoltage
1600          ********************************************************************************
1601          *
1602          * Summary:
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 27  

1603          *  Sets the reference voltage used by the watchdog to detect a failure in the
1604          *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1605          *
1606          * Parameters:
1607          *  setting: Valid range [0-7].
1608          *  Refer to the device TRM and datasheet for more information.
1609          *
1610          * Return:
1611          *  None
1612          *
1613          *******************************************************************************/
1614          void CyXTAL_SetWdVoltage(uint8 setting) 
1615          {
1616   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1617   1                                  (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1618   1      }
1619          
1620          
1621          /*******************************************************************************
1622          * Function Name: CyHalt
1623          ********************************************************************************
1624          *
1625          * Summary:
1626          *  Halts the CPU.
1627          *
1628          * Parameters:
1629          *  uint8 reason: Value to be used during debugging.
1630          *
1631          * Return:
1632          *  None
1633          *
1634          *******************************************************************************/
1635          void CyHalt(uint8 reason) CYREENTRANT
1636          {
1637   1          if(0u != reason)
1638   1          {
1639   2              /* To remove unreferenced local variable warning */
1640   2          }
1641   1      
1642   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__) || defined (__ICCARM__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1647   1              CYDEV_HALT_CPU;
1648   1          #endif  /* (__ARMCC_VERSION) */
1649   1      }
1650          
1651          
1652          /*******************************************************************************
1653          * Function Name: CySoftwareReset
1654          ********************************************************************************
1655          *
1656          * Summary:
1657          *  Forces a device software reset.
1658          *
1659          * Parameters:
1660          *  None
1661          *
1662          * Return:
1663          *  None
1664          *
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 28  

1665          *******************************************************************************/
1666          void CySoftwareReset(void) 
1667          {
1668   1          CY_LIB_RESET_CR2_REG |= CY_LIB_RESET_CR2_RESET;
1669   1      }
1670          
1671          
1672          /*******************************************************************************
1673          * Function Name: CyDelay
1674          ********************************************************************************
1675          *
1676          * Summary:
1677          *  Blocks for milliseconds.
1678          *
1679          *  Note:
1680          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1681          *  the instruction cache is disabled on PSoC5, CyDelay will be two times larger.
1682          *  For example, with instruction cache disabled CyDelay(100) would result in
1683          *  about 200 ms delay instead of 100 ms.
1684          *
1685          * Parameters:
1686          *  milliseconds: number of milliseconds to delay.
1687          *
1688          * Return:
1689          *   None
1690          *
1691          *******************************************************************************/
1692          void CyDelay(uint32 milliseconds) CYREENTRANT
1693          {
1694   1          while (milliseconds > 32768u)
1695   1          {
1696   2              /***********************************************************************
1697   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1698   2              * overflows at about 42 seconds.
1699   2              ***********************************************************************/
1700   2              CyDelayCycles(cydelay_32k_ms);
1701   2              milliseconds = ((uint32)(milliseconds - 32768u));
1702   2          }
1703   1      
1704   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1705   1      }
1706          
1707          
1708          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
                  /*******************************************************************************
                  * Function Name: CyDelayUs
                  ********************************************************************************
                  *
                  * Summary:
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
                  *   in about 200us delay instead of 100us.
                  *
                  * Parameters:
                  *  uint16 microseconds: number of microseconds to delay.
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 29  

                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When the instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with the instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1747          
1748          
1749          /*******************************************************************************
1750          * Function Name: CyDelayFreq
1751          ********************************************************************************
1752          *
1753          * Summary:
1754          *  Sets the clock frequency for CyDelay.
1755          *
1756          * Parameters:
1757          *  freq: The frequency of the bus clock in Hertz.
1758          *
1759          * Return:
1760          *  None
1761          *
1762          *******************************************************************************/
1763          void CyDelayFreq(uint32 freq) CYREENTRANT
1764          {
1765   1          if (freq != 0u)
1766   1          {
1767   2              cydelay_freq_hz = freq;
1768   2          }
1769   1          else
1770   1          {
1771   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1772   2          }
1773   1      
1774   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1775   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1776   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1777   1      }
1778          
1779          
1780          /*******************************************************************************
1781          * Function Name: CyWdtStart
1782          ********************************************************************************
1783          *
1784          * Summary:
1785          *  Enables the watchdog timer.
1786          *
1787          *  The timer is configured for the specified count interval, the central
1788          *  timewheel is cleared, the setting for the low power mode is configured and the
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 30  

1789          *  watchdog timer is enabled.
1790          *
1791          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1792          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1793          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1794          *  timer occur. The CTW is free running, so this will occur after between 2 and
1795          *  3 timer periods elapse.
1796          *
1797          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1798          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1799          *  set to be greater than the sleep wakeup period, then feed the dog on each
1800          *  wakeup from Sleep.
1801          *
1802          * Parameters:
1803          *  ticks: One of the four available timer periods. Once WDT enabled, the
1804             interval cannot be changed.
1805          *         CYWDT_2_TICKS     -     4 - 6     ms
1806          *         CYWDT_16_TICKS    -    32 - 48    ms
1807          *         CYWDT_128_TICKS   -   256 - 384   ms
1808          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1809          *
1810          *  lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1811          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1812          *
1813          *          CYWDT_LPMODE_NOCHANGE - No Change
1814          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1815          *                                 mode
1816          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1817          *
1818          * Return:
1819          *  None
1820          *
1821          * Side Effects:
1822          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1823          *  ILO 1 kHz could break the active WDT functionality.
1824          *
1825          *******************************************************************************/
1826          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1827          {
1828   1          /* Set WDT interval */
1829   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1830   1      
1831   1          /* Reset CTW to ensure that first watchdog period is full */
1832   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1833   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1834   1      
1835   1          /* Setting low power mode */
1836   1          CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1837   1                             (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1838   1      
1839   1          /* Enables watchdog reset */
1840   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1841   1      }
1842          
1843          
1844          /*******************************************************************************
1845          * Function Name: CyWdtClear
1846          ********************************************************************************
1847          *
1848          * Summary:
1849          *  Clears (feeds) the watchdog timer.
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 31  

1850          *
1851          * Parameters:
1852          *  None
1853          *
1854          * Return:
1855          *  None
1856          *
1857          *******************************************************************************/
1858          void CyWdtClear(void) 
1859          {
1860   1          CY_WDT_CR_REG = CY_WDT_CR_FEED;
1861   1      }
1862          
1863          
1864          
1865          /*******************************************************************************
1866          * Function Name: CyVdLvDigitEnable
1867          ********************************************************************************
1868          *
1869          * Summary:
1870          *  Enables the digital low voltage monitors to generate interrupt on Vddd
1871          *   archives specified threshold and optionally resets the device.
1872          *
1873          * Parameters:
1874          *  reset: The option to reset the device at a specified Vddd threshold:
1875          *           0 - Device is not reset.
1876          *           1 - Device is reset.
1877          *
1878          *  threshold: Sets the trip level for the voltage monitor.
1879          *  Values from 1.70 V to 5.45 V are accepted with an interval  of approximately
1880          *  250 mV.
1881          *
1882          * Return:
1883          *  None
1884          *
1885          *******************************************************************************/
1886          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
1887          {
1888   1          *CY_INT_CLEAR_PTR = 0x01u;
1889   1      
1890   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1891   1      
1892   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1893   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
1894   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
1895   1      
1896   1          /* Timeout to eliminate glitches on LVI/HVI when enabling */
1897   1          CyDelayUs(1u);
1898   1      
1899   1          (void)CY_VD_PERSISTENT_STATUS_REG;
1900   1      
1901   1          if(0u != reset)
1902   1          {
1903   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1904   2          }
1905   1          else
1906   1          {
1907   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1908   2          }
1909   1      
1910   1          *CY_INT_CLR_PEND_PTR = 0x01u;
1911   1          *CY_INT_ENABLE_PTR   = 0x01u;
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 32  

1912   1      }
1913          
1914          
1915          /*******************************************************************************
1916          * Function Name: CyVdLvAnalogEnable
1917          ********************************************************************************
1918          *
1919          * Summary:
1920          *  Enables the analog low voltage monitors to generate interrupt on Vdda
1921          *   archives specified threshold and optionally resets the device.
1922          *
1923          * Parameters:
1924          *  reset: The option to reset the device at a specified Vdda threshold:
1925          *           0 - Device is not reset.
1926          *           1 - Device is reset.
1927          *
1928          *  threshold: Sets the trip level for the voltage monitor.
1929          *  Values from 1.70 V to 5.45 V are accepted with the approximately 250 mV
1930          *  interval.
1931          *
1932          * Return:
1933          *  None
1934          *
1935          *******************************************************************************/
1936          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
1937          {
1938   1          *CY_INT_CLEAR_PTR = 0x01u;
1939   1      
1940   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1941   1      
1942   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
1943   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
1944   1      
1945   1          /* Timeout to eliminate glitches on LVI/HVI when enabling */
1946   1          CyDelayUs(1u);
1947   1      
1948   1          (void)CY_VD_PERSISTENT_STATUS_REG;
1949   1      
1950   1          if(0u != reset)
1951   1          {
1952   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
1953   2          }
1954   1          else
1955   1          {
1956   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1957   2          }
1958   1      
1959   1          *CY_INT_CLR_PEND_PTR = 0x01u;
1960   1          *CY_INT_ENABLE_PTR   = 0x01u;
1961   1      }
1962          
1963          
1964          /*******************************************************************************
1965          * Function Name: CyVdLvDigitDisable
1966          ********************************************************************************
1967          *
1968          * Summary:
1969          *  Disables the digital low voltage monitor (interrupt and device reset are
1970          *  disabled).
1971          *
1972          * Parameters:
1973          *  None
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 33  

1974          *
1975          * Return:
1976          *  None
1977          *
1978          *******************************************************************************/
1979          void CyVdLvDigitDisable(void) 
1980          {
1981   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
1982   1      
1983   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1984   1      
1985   1          while(0u != (CY_VD_PERSISTENT_STATUS_REG & 0x07u))
1986   1          {
1987   2      
1988   2          }
1989   1      }
1990          
1991          
1992          /*******************************************************************************
1993          * Function Name: CyVdLvAnalogDisable
1994          ********************************************************************************
1995          *
1996          * Summary:
1997          *  Disables the analog low voltage monitor (interrupt and device reset are
1998          *  disabled).
1999          *
2000          * Parameters:
2001          *  None
2002          *
2003          * Return:
2004          *  None
2005          *
2006          *******************************************************************************/
2007          void CyVdLvAnalogDisable(void) 
2008          {
2009   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
2010   1      
2011   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2012   1      
2013   1          while(0u != (CY_VD_PERSISTENT_STATUS_REG & 0x07u))
2014   1          {
2015   2      
2016   2          }
2017   1      }
2018          
2019          
2020          /*******************************************************************************
2021          * Function Name: CyVdHvAnalogEnable
2022          ********************************************************************************
2023          *
2024          * Summary:
2025          *  Enables the analog high voltage monitors to generate interrupt on
2026          *  Vdda archives 5.75 V threshold and optionally resets device.
2027          *
2028          * Parameters:
2029          *  None
2030          *
2031          * Return:
2032          *  None
2033          *
2034          *******************************************************************************/
2035          void CyVdHvAnalogEnable(void) 
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 34  

2036          {
2037   1          *CY_INT_CLEAR_PTR = 0x01u;
2038   1      
2039   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2040   1      
2041   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
2042   1      
2043   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling */
2044   1          CyDelayUs(1u);
2045   1      
2046   1          (void) CY_VD_PERSISTENT_STATUS_REG;
2047   1      
2048   1          *CY_INT_CLR_PEND_PTR = 0x01u;
2049   1          *CY_INT_ENABLE_PTR   = 0x01u;
2050   1      }
2051          
2052          
2053          /*******************************************************************************
2054          * Function Name: CyVdHvAnalogDisable
2055          ********************************************************************************
2056          *
2057          * Summary:
2058          *  Disables the analog low voltage monitor
2059          *  (interrupt and device reset are disabled).
2060          *
2061          * Parameters:
2062          *  None
2063          *
2064          * Return:
2065          *  None
2066          *
2067          *******************************************************************************/
2068          void CyVdHvAnalogDisable(void) 
2069          {
2070   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
2071   1      }
2072          
2073          
2074          /*******************************************************************************
2075          * Function Name: CyVdStickyStatus
2076          ********************************************************************************
2077          *
2078          * Summary:
2079          *  Manages the Reset and Voltage Detection Status Register 0.
2080          *  This register has the interrupt status for the HVIA, LVID and LVIA.
2081          *  This hardware register clears on read.
2082          *
2083          * Parameters:
2084          *  mask: Bits in the shadow register to clear.
2085          *   Define                  Definition
2086          *   CY_VD_LVID            Persistent status of digital LVI.
2087          *   CY_VD_LVIA            Persistent status of analog LVI.
2088          *   CY_VD_HVIA            Persistent status of analog HVI.
2089          *
2090          * Return:
2091          *  Status.  Same enumerated bit values as used for the mask parameter.
2092          *
2093          *******************************************************************************/
2094          uint8 CyVdStickyStatus(uint8 mask) 
2095          {
2096   1          uint8 status;
2097   1      
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 35  

2098   1          status = CY_VD_PERSISTENT_STATUS_REG;
2099   1          CY_VD_PERSISTENT_STATUS_REG &= ((uint8)(~mask));
2100   1      
2101   1          return(status);
2102   1      }
2103          
2104          
2105          /*******************************************************************************
2106          * Function Name: CyVdRealTimeStatus
2107          ********************************************************************************
2108          *
2109          * Summary:
2110          *  Returns the real time voltage detection status.
2111          *
2112          * Parameters:
2113          *  None
2114          *
2115          * Return:
2116          *  Status:
2117          *   Define                  Definition
2118          *   CY_VD_LVID            Persistent status of digital LVI.
2119          *   CY_VD_LVIA            Persistent status of analog LVI.
2120          *   CY_VD_HVIA            Persistent status of analog HVI.
2121          *
2122          *******************************************************************************/
2123          uint8 CyVdRealTimeStatus(void) 
2124          {
2125   1          uint8 interruptState;
2126   1          uint8 vdFlagsState;
2127   1      
2128   1          interruptState = CyEnterCriticalSection();
2129   1          vdFlagsState = CY_VD_RT_STATUS_REG;
2130   1          CyExitCriticalSection(interruptState);
2131   1      
2132   1          return(vdFlagsState);
2133   1      }
2134          
2135          
2136          /*******************************************************************************
2137          * Function Name: CyDisableInts
2138          ********************************************************************************
2139          *
2140          * Summary:
2141          *  Disables the interrupt enable for each interrupt.
2142          *
2143          * Parameters:
2144          *  None
2145          *
2146          * Return:
2147          *  32 bit mask of previously enabled interrupts.
2148          *
2149          *******************************************************************************/
2150          uint32 CyDisableInts(void) 
2151          {
2152   1          uint32 intState;
2153   1          uint8 interruptState;
2154   1      
2155   1          interruptState = CyEnterCriticalSection();
2156   1      
2157   1          #if(CY_PSOC3)
2158   1      
2159   1              /* Get the current interrupt state. */
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 36  

2160   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
2161   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
2162   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
2163   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
2164   1      
2165   1      
2166   1              /* Disable all of the interrupts. */
2167   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
2168   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
2169   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
2170   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
2171   1      
2172   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2181   1      
2182   1          CyExitCriticalSection(interruptState);
2183   1      
2184   1          return (intState);
2185   1      }
2186          
2187          
2188          /*******************************************************************************
2189          * Function Name: CyEnableInts
2190          ********************************************************************************
2191          *
2192          * Summary:
2193          *  Enables interrupts to a given state.
2194          *
2195          * Parameters:
2196          *  uint32 mask: 32 bit mask of interrupts to enable.
2197          *
2198          * Return:
2199          *  None
2200          *
2201          *******************************************************************************/
2202          void CyEnableInts(uint32 mask) 
2203          {
2204   1      
2205   1          uint8 interruptState;
2206   1      
2207   1          interruptState = CyEnterCriticalSection();
2208   1      
2209   1          #if(CY_PSOC3)
2210   1      
2211   1              /* Set interrupts as enabled. */
2212   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2213   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2214   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2215   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
2216   1      
2217   1          #else
              
                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
              
                  #endif /* (CY_PSOC3) */
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 37  

2222   1      
2223   1          CyExitCriticalSection(interruptState);
2224   1      
2225   1      }
2226          
2227          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ********************************************************************************
                  * Summary:
                  *  Flushes the PSoC 5/5LP cache by invalidating all entries.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in cache are invalidated on next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
                      /* Once this is executed it's guaranteed the cache has been flushed */
                      (void) CY_CACHE_CONTROL_REG;
              
                      /* Flush the pipeline */
                      CY_SYS_ISB;
              
                      /* Restore global interrupt enable state */
                      CyExitCriticalSection(interruptState);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ********************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 38  

                  * Summary:
                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEM_MANAGE_IRQN         - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  *  address: Pointer to an interrupt service routine.
                  *
                  * Return:
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEMORY_MANAGEMENT_IRQN  - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  * Return:
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 39  

                  *   Address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *  address: Pointer to an interrupt service routine
                  *
                  * Return:
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *
                  * Return:
                  *  The address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 40  

              
                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
              
                      return (priority);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ********************************************************************************
                  *
                  * Summary:
                  *   Gets the enable state of the specified interrupt number.
                  *
                  * Parameters:
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 41  

                  *   number: Valid range [0-31].  Interrupt number.
                  *
                  * Return:
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Get pointer to Interrupt enable register. */
                      stateReg = CY_INT_ENABLE_PTR;
              
                      /* Get state of interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2491          
2492          
2493              /*******************************************************************************
2494              * Function Name: CyIntSetVector
2495              ********************************************************************************
2496              *
2497              * Summary:
2498              *  Sets the interrupt vector of the specified interrupt number.
2499              *
2500              * Parameters:
2501              *  number:  Valid range [0-31].  Interrupt number
2502              *  address: Pointer to an interrupt service routine
2503              *
2504              * Return:
2505              *  Previous interrupt vector value.
2506              *
2507              *******************************************************************************/
2508              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2509              {
2510   1              cyisraddress oldIsr;
2511   1      
2512   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2513   1      
2514   1              /* Save old Interrupt service routine. */
2515   1              oldIsr = (cyisraddress) \
2516   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2517   1      
2518   1              /* Set new Interrupt service routine. */
2519   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2520   1      
2521   1              return (oldIsr);
2522   1          }
2523          
2524          
2525              /*******************************************************************************
2526              * Function Name: CyIntGetVector
2527              ********************************************************************************
2528              *
2529              * Summary:
2530              *  Gets the interrupt vector of the specified interrupt number.
2531              *
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 42  

2532              * Parameters:
2533              *  number: Valid range [0-31].  Interrupt number
2534              *
2535              * Return:
2536              *  Address of the ISR in the interrupt vector table.
2537              *
2538              *******************************************************************************/
2539              cyisraddress CyIntGetVector(uint8 number) 
2540              {
2541   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2542   1      
2543   1              return ((cyisraddress) \
2544   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
2545   1          }
2546          
2547          
2548              /*******************************************************************************
2549              * Function Name: CyIntSetPriority
2550              ********************************************************************************
2551              *
2552              * Summary:
2553              *  Sets the Priority of the Interrupt.
2554              *
2555              * Parameters:
2556              *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2557              *  number:   The number of the interrupt, 0 - 31.
2558              *
2559              * Return:
2560              *  None
2561              *
2562              *******************************************************************************/
2563              void CyIntSetPriority(uint8 number, uint8 priority) 
2564              {
2565   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2566   1      
2567   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2568   1      
2569   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2570   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
2571   1          }
2572          
2573          
2574              /*******************************************************************************
2575              * Function Name: CyIntGetPriority
2576              ********************************************************************************
2577              *
2578              * Summary:
2579              *  Gets the Priority of the Interrupt.
2580              *
2581              * Parameters:
2582              *  number: The number of the interrupt, 0 - 31.
2583              *
2584              * Return:
2585              *  Priority of the interrupt. 0 - 7, 0 being the highest.
2586              *
2587              *******************************************************************************/
2588              uint8 CyIntGetPriority(uint8 number) 
2589              {
2590   1              uint8 priority;
2591   1      
2592   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2593   1      
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 43  

2594   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
2595   1      
2596   1              return (priority);
2597   1          }
2598          
2599          
2600              /*******************************************************************************
2601              * Function Name: CyIntGetState
2602              ********************************************************************************
2603              *
2604              * Summary:
2605              *   Gets the enable state of the specified interrupt number.
2606              *
2607              * Parameters:
2608              *   number: Valid range [0-31].  Interrupt number.
2609              *
2610              * Return:
2611              *   Enable status: 1 if enabled, 0 if disabled
2612              *
2613              *******************************************************************************/
2614              uint8 CyIntGetState(uint8 number) 
2615              {
2616   1              reg8 * stateReg;
2617   1      
2618   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2619   1      
2620   1              /* Get pointer to Interrupt enable register. */
2621   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2622   1      
2623   1              /* Get state of interrupt. */
2624   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2625   1          }
2626          
2627          
2628          #endif  /* (CY_PSOC5) */
2629          
2630          
2631          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  /*******************************************************************************
                  * Function Name: CySetScPumps
                  ********************************************************************************
                  *
                  * Summary:
                  *  If 1 is passed as a parameter:
                  *   - if any of the SC blocks are used - enable pumps for the SC blocks and
                  *     start boost clock.
                  *   - For each enabled SC block set a boost clock index and enable the boost
                  *     clock.
                  *
                  *  If non-1 value is passed as a parameter:
                  *   - If all SC blocks are not used - disable pumps for the SC blocks and
                  *     stop the boost clock.
                  *   - For each enabled SC block clear the boost clock index and disable the  boost
                  *     clock.
                  *
                  *  The global variable CyScPumpEnabled is updated to be equal to passed the
                  *  parameter.
                  *
                  * Parameters:
                  *   uint8 enable: Enable/disable SC pumps and the boost clock for the enabled SC block.
                  *                 1 - Enable
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 44  

                  *                 0 - Disable
                  *
                  * Return:
                  *   None
                  *
                  *******************************************************************************/
                  void CySetScPumps(uint8 enable) 
                  {
                      if(1u == enable)
                      {
                          /* The SC pumps should be enabled */
                          CyScPumpEnabled = 1u;
                          /* Enable pumps if any of SC blocks are used */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                          {
                              CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
                              CyScBoostClk_Start();
                          }
                          /* Set positive pump for each enabled SC block: set clock index and enable it */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                          {
                              CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                          {
                              CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                          {
                              CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                          {
                              CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                      }
                      else
                      {
                          /* The SC pumps should be disabled */
                          CyScPumpEnabled = 0u;
                          /* Disable pumps for all SC blocks and stop boost clock */
                          CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                          CyScBoostClk_Stop();
                          /* Disable boost clock and clear clock index for each SC block */
                          CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                      }
                  }
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 45  

              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2716          
2717          
2718          #if(CY_PSOC5)
                  /*******************************************************************************
                  * Function Name: CySysTickStart
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the SysTick timer to generate interrupt every 1 ms by call to the
                  *  CySysTickInit() function and starts it by calling CySysTickEnable() function.
                  *  Refer to the corresponding function description for the details.
              
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStart(void)
                  {
                      if (0u == CySysTickInitVar)
                      {
                          CySysTickInit();
                          CySysTickInitVar = 1u;
                      }
              
                      CySysTickEnable();
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickInit
                  ********************************************************************************
                  *
                  * Summary:
                  *  Initializes the callback addresses with pointers to NULL, associates the
                  *  SysTick system vector with the function that is responsible for calling
                  *  registered callback functions, configures SysTick timer to generate interrupt
                  * every 1 ms.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set.
                  *
                  *  The 1 ms interrupt interval is configured based on the frequency determined
                  *  by PSoC Creator at build time. If System clock frequency is changed in
                  *  runtime, the CyDelayFreq() with the appropriate parameter should be called.
                  *
                  *******************************************************************************/
                  void CySysTickInit(void)
                  {
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 46  

                      uint32 i;
              
                      for (i = 0u; i<CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                      {
                          CySysTickCallbacks[i] = (void *) 0;
                      }
              
                      (void) CyIntSetSysVector(CY_INT_SYSTICK_IRQN, &CySysTickServiceCallbacks);
                      CySysTickSetClockSource(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK);
                      CySysTickSetReload(cydelay_freq_hz/1000u);
                      CySysTickClear();
                      CyIntEnable(CY_INT_SYSTICK_IRQN);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnable
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick timer and its interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnable(void)
                  {
                      CySysTickEnableInterrupt();
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickStop
                  ********************************************************************************
                  *
                  * Summary:
                  *  Stops the system timer (SysTick).
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStop(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE));
                  }
              
              
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 47  

                  /*******************************************************************************
                  * Function Name: CySysTickEnableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE_INT;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickDisableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Disables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickDisableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE_INT));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero. This
                  *  function do not change or reset current sysTick counter value, so it should
                  *  be cleared using CySysTickClear() API.
                  *
                  * Parameters:
                  *  value: Valid range [0x0-0x00FFFFFF]. Counter reset value.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 48  

                  void CySysTickSetReload(uint32 value)
                  {
                      CY_SYS_SYST_RVR_REG = (value & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Counter reset value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetReload(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetValue
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets current SysTick counter value.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Current SysTick counter value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetValue(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_CVR_REG);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetClockSource
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the clock source for the SysTick counter.
                  *
                  * Parameters:
                  *  clockSource: Clock source for SysTick counter
                  *         Define                     Clock Source
                  *   CY_SYS_SYST_CSR_CLK_SRC_SYSCLK     SysTick is clocked by CPU clock.
                  *   CY_SYS_SYST_CSR_CLK_SRC_LFCLK      SysTick is clocked by the low frequency
                  *                              clock (ILO 100 KHz for PSoC 5LP, LFCLK for PSoC 4).
                  *
                  * Return:
                  *  None
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 49  

                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set. If clock source is not ready this
                  *  function call will have no effect. After changing clock source to the low frequency
                  *  clock the counter and reload register values will remain unchanged so time to
                  *  the interrupt will be significantly bigger and vice versa.
                  *
                  *******************************************************************************/
                  void CySysTickSetClockSource(uint32 clockSource)
                  {
                      if (clockSource == CY_SYS_SYST_CSR_CLK_SRC_SYSCLK)
                      {
                          CY_SYS_SYST_CSR_REG |= (uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURCE_S
             -HIFT);
                      }
                      else
                      {
                          CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURC
             -E_SHIFT));
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCountFlag
                  ********************************************************************************
                  *
                  * Summary:
                  *  The count flag is set once SysTick counter reaches zero.
                  *   The flag cleared on read.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Returns non-zero value if counter is set, otherwise zero is returned.
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetCountFlag(void)
                  {
                      return ((CY_SYS_SYST_CSR_REG>>CY_SYS_SYST_CSR_COUNTFLAG_SHIFT) & 0x01u);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickClear
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the SysTick counter for well-defined startup.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickClear(void)
                  {
                      CY_SYS_SYST_CVR_REG = 0u;
                  }
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 50  

              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetCallback
                  ********************************************************************************
                  *
                  * Summary:
                  *  The function set the pointers to the functions that will be called on
                  *  SysTick interrupt.
                  *
                  * Parameters:
                  *  number:  The number of callback function address to be set.
                  *           The valid range is from 0 to 4.
                  *  CallbackFunction: Function address.
                  *
                  * Return:
                  *  Returns the address of the previous callback function.
                  *  The NULL is returned if the specified address in not set.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickSetCallback(uint32 number, cySysTickCallback function)
                  {
                      cySysTickCallback retVal;
              
                      retVal = CySysTickCallbacks[number];
                      CySysTickCallbacks[number] = function;
                      return (retVal);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCallback
                  ********************************************************************************
                  *
                  * Summary:
                  *  The function get the specified callback pointer.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickGetCallback(uint32 number)
                  {
                      return ((cySysTickCallback) CySysTickCallbacks[number]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickServiceCallbacks
                  ********************************************************************************
                  *
                  * Summary:
                  *  System Tick timer interrupt routine
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 51  

                  *
                  *******************************************************************************/
                  static void CySysTickServiceCallbacks(void)
                  {
                      uint32 i;
              
                      /* Verify that tick timer flag was set */
                      if (1u == CySysTickGetCountFlag())
                      {
                          for (i=0u; i < CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                          {
                              if (CySysTickCallbacks[i] != (void *) 0)
                              {
                                  (void)(CySysTickCallbacks[i])();
                              }
                          }
                      }
                  }
              #endif /* (CY_PSOC5) */
3103          
3104          
3105          /* [] END OF FILE */
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 52  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION _CyPLL_OUT_Start (BEGIN)
                                           ; SOURCE LINE # 95
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 96
                                           ; SOURCE LINE # 97
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#status
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 105
0005 904220            MOV     DPTR,#04220H
0008 E0                MOVX    A,@DPTR
0009 4401              ORL     A,#01H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 107
000C EF                MOV     A,R7
000D 6059              JZ      ?C0001
                                           ; SOURCE LINE # 108
                                           ; SOURCE LINE # 110
000F 904300            MOV     DPTR,#04300H
0012 E0                MOVX    A,@DPTR
0013 5404              ANL     A,#04H
0015 900000      R     MOV     DPTR,#iloEnableState
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 111
0019 904380            MOV     DPTR,#04380H
001C E0                MOVX    A,@DPTR
001D 900000      R     MOV     DPTR,#pmTwCfg0State
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 112
0021 904382            MOV     DPTR,#04382H
0024 E0                MOVX    A,@DPTR
0025 900000      R     MOV     DPTR,#pmTwCfg2State
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 114
0029 7F18              MOV     R7,#018H
002B 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 116
002E 900000      R     MOV     DPTR,#status
0031 7410              MOV     A,#010H
0033 F0                MOVX    @DPTR,A
0034         ?C0002:
                                           ; SOURCE LINE # 118
0034 7F01              MOV     R7,#01H
0036 120000      E     LCALL   _CyPmReadStatus
0039 EF                MOV     A,R7
003A 20E012            JB      ACC.0,?C0003
                                           ; SOURCE LINE # 119
                                           ; SOURCE LINE # 121
003D 904225            MOV     DPTR,#04225H
0040 E0                MOVX    A,@DPTR
0041 5401              ANL     A,#01H
0043 60EF              JZ      ?C0002
                                           ; SOURCE LINE # 122
                                           ; SOURCE LINE # 123
0045 E0                MOVX    A,@DPTR
0046 5401              ANL     A,#01H
0048 60EA              JZ      ?C0002
                                           ; SOURCE LINE # 124
                                           ; SOURCE LINE # 125
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 53  

004A E4                CLR     A
004B 900000      R     MOV     DPTR,#status
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
                                           ; SOURCE LINE # 127
                                           ; SOURCE LINE # 128
                                           ; SOURCE LINE # 129
004F         ?C0003:
                                           ; SOURCE LINE # 132
004F 900000      R     MOV     DPTR,#iloEnableState
0052 E0                MOVX    A,@DPTR
0053 7003              JNZ     ?C0006
                                           ; SOURCE LINE # 133
                                           ; SOURCE LINE # 134
0055 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 135
0058         ?C0006:
                                           ; SOURCE LINE # 137
0058 900000      R     MOV     DPTR,#pmTwCfg0State
005B E0                MOVX    A,@DPTR
005C 904380            MOV     DPTR,#04380H
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 138
0060 900000      R     MOV     DPTR,#pmTwCfg2State
0063 E0                MOVX    A,@DPTR
0064 904382            MOV     DPTR,#04382H
0067 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 139
0068         ?C0001:
                                           ; SOURCE LINE # 141
0068 900000      R     MOV     DPTR,#status
006B E0                MOVX    A,@DPTR
006C FF                MOV     R7,A
                                           ; SOURCE LINE # 142
006D         ?C0007:
006D 22                RET     
             ; FUNCTION _CyPLL_OUT_Start (END)

             ; FUNCTION CyPLL_OUT_Stop (BEGIN)
                                           ; SOURCE LINE # 159
                                           ; SOURCE LINE # 160
                                           ; SOURCE LINE # 161
0000 904220            MOV     DPTR,#04220H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 162
0007 22                RET     
             ; FUNCTION CyPLL_OUT_Stop (END)

             ; FUNCTION _CyPLL_OUT_SetPQ (BEGIN)
                                           ; SOURCE LINE # 197
0000 900000      R     MOV     DPTR,#pDiv
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 A3                INC     DPTR
0009 EB                MOV     A,R3
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 54  

                                           ; SOURCE LINE # 200
000B 904220            MOV     DPTR,#04220H
000E E0                MOVX    A,@DPTR
000F 5401              ANL     A,#01H
0011 7003              JNZ     ?C0010
0013 D3                SETB    C
0014 8001              SJMP    ?C0011
0016         ?C0010:
0016 C3                CLR     C
0017         ?C0011:
0017 4005              JC      ?C0009
0019 7F00              MOV     R7,#00H
001B 120000      R     LCALL   _?CyHalt
001E         ?C0009:
                                           ; SOURCE LINE # 202
001E 900000      R     MOV     DPTR,#pDiv
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 C3                CLR     C
0024 9408              SUBB    A,#08H
0026 403C              JC      ?C0012
0028 A3                INC     DPTR
0029 E0                MOVX    A,@DPTR
002A FE                MOV     R6,A
002B D3                SETB    C
002C 9410              SUBB    A,#010H
002E 5034              JNC     ?C0012
0030 EE                MOV     A,R6
0031 C3                CLR     C
0032 9401              SUBB    A,#01H
0034 402E              JC      ?C0012
0036 A3                INC     DPTR
0037 E0                MOVX    A,@DPTR
0038 FE                MOV     R6,A
0039 9401              SUBB    A,#01H
003B 4027              JC      ?C0012
003D EE                MOV     A,R6
003E D3                SETB    C
003F 9407              SUBB    A,#07H
0041 5021              JNC     ?C0012
                                           ; SOURCE LINE # 205
                                           ; SOURCE LINE # 207
0043 904222            MOV     DPTR,#04222H
0046 EF                MOV     A,R7
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 208
0048 900000      R     MOV     DPTR,#qDiv
004B E0                MOVX    A,@DPTR
004C 14                DEC     A
004D 904223            MOV     DPTR,#04223H
0050 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 210
0051 900000      R     MOV     DPTR,#current
0054 E0                MOVX    A,@DPTR
0055 14                DEC     A
0056 FF                MOV     R7,A
0057 C4                SWAP    A
0058 54F0              ANL     A,#0F0H
005A FF                MOV     R7,A
005B 904221            MOV     DPTR,#04221H
005E E0                MOVX    A,@DPTR
005F 548F              ANL     A,#08FH
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 55  

0061 4F                ORL     A,R7
0062 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 211
0063 22                RET     
0064         ?C0012:
                                           ; SOURCE LINE # 213
                                           ; SOURCE LINE # 220
0064 7F00              MOV     R7,#00H
0066 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 221
                                           ; SOURCE LINE # 223
0069         ?C0015:
0069 22                RET     
             ; FUNCTION _CyPLL_OUT_SetPQ (END)

             ; FUNCTION _CyPLL_OUT_SetSource (BEGIN)
                                           ; SOURCE LINE # 252
0000 900000      R     MOV     DPTR,#source
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 253
                                           ; SOURCE LINE # 255
0005 904220            MOV     DPTR,#04220H
0008 E0                MOVX    A,@DPTR
0009 5401              ANL     A,#01H
000B 7003              JNZ     ?C0017
000D D3                SETB    C
000E 8001              SJMP    ?C0018
0010         ?C0017:
0010 C3                CLR     C
0011         ?C0018:
0011 4005              JC      ?C0016
0013 7F00              MOV     R7,#00H
0015 120000      R     LCALL   _?CyHalt
0018         ?C0016:
                                           ; SOURCE LINE # 257
0018 900000      R     MOV     DPTR,#source
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D 24FD              ADD     A,#0FDH
001F 5002              JNC     ?C0022
0021 8009              SJMP    ?C0023
                                           ; SOURCE LINE # 258
                                           ; SOURCE LINE # 259
                                           ; SOURCE LINE # 260
                                           ; SOURCE LINE # 261
0023         ?C0022:
                                           ; SOURCE LINE # 262
0023 904000            MOV     DPTR,#04000H
0026 E0                MOVX    A,@DPTR
0027 54FC              ANL     A,#0FCH
0029 4F                ORL     A,R7
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 263
002B 22                RET     
                                           ; SOURCE LINE # 265
002C         ?C0023:
                                           ; SOURCE LINE # 266
002C 7F00              MOV     R7,#00H
002E 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 268
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 56  

                                           ; SOURCE LINE # 269
0031         ?C0025:
0031 22                RET     
             ; FUNCTION _CyPLL_OUT_SetSource (END)

             ; FUNCTION _CyIMO_Start (BEGIN)
                                           ; SOURCE LINE # 302
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 303
                                           ; SOURCE LINE # 309
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 310
0007 9043B0            MOV     DPTR,#043B0H
000A E0                MOVX    A,@DPTR
000B 4410              ORL     A,#010H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 312
000E EF                MOV     A,R7
000F 6041              JZ      ?C0030
                                           ; SOURCE LINE # 313
                                           ; SOURCE LINE # 315
0011 904300            MOV     DPTR,#04300H
0014 E0                MOVX    A,@DPTR
0015 5404              ANL     A,#04H
0017 900000      R     MOV     DPTR,#ilo100KhzEnable
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 316
001B 904380            MOV     DPTR,#04380H
001E E0                MOVX    A,@DPTR
001F 900000      R     MOV     DPTR,#pmFtwCfg0Reg
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 317
0023 904382            MOV     DPTR,#04382H
0026 E0                MOVX    A,@DPTR
0027 900000      R     MOV     DPTR,#pmFtwCfg2Reg
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 319
002B E4                CLR     A
002C FF                MOV     R7,A
002D 120000      E     LCALL   _CyPmFtwSetInterval
0030         ?C0027:
                                           ; SOURCE LINE # 321
0030 7F01              MOV     R7,#01H
0032 120000      E     LCALL   _CyPmReadStatus
0035 EF                MOV     A,R7
0036 30E0F7            JNB     ACC.0,?C0027
                                           ; SOURCE LINE # 322
                                           ; SOURCE LINE # 324
0039         ?C0028:
                                           ; SOURCE LINE # 326
0039 900000      R     MOV     DPTR,#ilo100KhzEnable
003C E0                MOVX    A,@DPTR
003D 7003              JNZ     ?C0029
                                           ; SOURCE LINE # 327
                                           ; SOURCE LINE # 328
003F 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 329
0042         ?C0029:
                                           ; SOURCE LINE # 331
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 57  

0042 900000      R     MOV     DPTR,#pmFtwCfg0Reg
0045 E0                MOVX    A,@DPTR
0046 904380            MOV     DPTR,#04380H
0049 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 332
004A 900000      R     MOV     DPTR,#pmFtwCfg2Reg
004D E0                MOVX    A,@DPTR
004E 904382            MOV     DPTR,#04382H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 333
                                           ; SOURCE LINE # 334
0052         ?C0030:
0052 22                RET     
             ; FUNCTION _CyIMO_Start (END)

             ; FUNCTION CyIMO_Stop (BEGIN)
                                           ; SOURCE LINE # 351
                                           ; SOURCE LINE # 352
                                           ; SOURCE LINE # 353
0000 9043A0            MOV     DPTR,#043A0H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 354
0007 9043B0            MOV     DPTR,#043B0H
000A E0                MOVX    A,@DPTR
000B 54EF              ANL     A,#0EFH
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 355
000E 22                RET     
             ; FUNCTION CyIMO_Stop (END)

             ; FUNCTION CyUSB_PowerOnCheck (BEGIN)
                                           ; SOURCE LINE # 372
                                           ; SOURCE LINE # 373
                                           ; SOURCE LINE # 374
;---- Variable 'poweredOn' assigned to Register 'R7' ----
0000 E4                CLR     A
0001 FF                MOV     R7,A
                                           ; SOURCE LINE # 380
0002 904393            MOV     DPTR,#04393H
0005 E0                MOVX    A,@DPTR
0006 5407              ANL     A,#07H
0008 7008              JNZ     ?C0034
000A 9043A5            MOV     DPTR,#043A5H
000D E0                MOVX    A,@DPTR
000E 5401              ANL     A,#01H
0010 7012              JNZ     ?C0033
0012         ?C0034:
0012 904393            MOV     DPTR,#04393H
0015 E0                MOVX    A,@DPTR
0016 5407              ANL     A,#07H
0018 6401              XRL     A,#01H
001A 700A              JNZ     ?C0032
001C 9043B5            MOV     DPTR,#043B5H
001F E0                MOVX    A,@DPTR
0020 5401              ANL     A,#01H
0022 6002              JZ      ?C0032
0024         ?C0033:
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
0024 7F01              MOV     R7,#01H
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 58  

                                           ; SOURCE LINE # 383
0026         ?C0032:
                                           ; SOURCE LINE # 385
                                           ; SOURCE LINE # 386
0026         ?C0035:
0026 22                RET     
             ; FUNCTION CyUSB_PowerOnCheck (END)

             ; FUNCTION _CyIMO_SetTrimValue (BEGIN)
                                           ; SOURCE LINE # 403
;---- Variable 'freq' assigned to Register 'R6' ----
0000 AE07              MOV     R6,AR7
                                           ; SOURCE LINE # 404
                                           ; SOURCE LINE # 405
0002 120000      R     LCALL   CyUSB_PowerOnCheck
0005 900000      R     MOV     DPTR,#usbPowerOn
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 408
000A B40107            CJNE    A,#01H,?C0036
                                           ; SOURCE LINE # 409
                                           ; SOURCE LINE # 411
000D 906009            MOV     DPTR,#06009H
0010 E0                MOVX    A,@DPTR
0011 54FD              ANL     A,#0FDH
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 412
0014         ?C0036:
                                           ; SOURCE LINE # 413
0014 EE                MOV     A,R6
0015 120000      E     LCALL   ?C?CCASE
0018 0000        R     DW      ?C0038
001A 00                DB      00H
001B 0000        R     DW      ?C0039
001D 01                DB      01H
001E 0000        R     DW      ?C0040
0020 02                DB      02H
0021 0000        R     DW      ?C0041
0023 03                DB      03H
0024 0000        R     DW      ?C0042
0026 04                DB      04H
0027 0000        R     DW      ?C0043
0029 05                DB      05H
002A 0000        R     DW      ?C0044
002C 08                DB      08H
002D 0000              DW      00H
002F 0000        R     DW      ?C0046
                                           ; SOURCE LINE # 414
                                           ; SOURCE LINE # 415
0031         ?C0038:
                                           ; SOURCE LINE # 416
0031 7B0C              MOV     R3,#0CH
0033 7A01              MOV     R2,#01H
0035 7908              MOV     R1,#08H
0037 120000      E     LCALL   _cyread8
003A 9046A1            MOV     DPTR,#046A1H
003D EF                MOV     A,R7
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 417
003F 22                RET     
                                           ; SOURCE LINE # 419
0040         ?C0039:
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 59  

                                           ; SOURCE LINE # 420
0040 7B0C              MOV     R3,#0CH
0042 7A01              MOV     R2,#01H
0044 7909              MOV     R1,#09H
0046 120000      E     LCALL   _cyread8
0049 9046A1            MOV     DPTR,#046A1H
004C EF                MOV     A,R7
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 421
004E 22                RET     
                                           ; SOURCE LINE # 423
004F         ?C0040:
                                           ; SOURCE LINE # 424
004F 7B0C              MOV     R3,#0CH
0051 7A01              MOV     R2,#01H
0053 790A              MOV     R1,#0AH
0055 120000      E     LCALL   _cyread8
0058 9046A1            MOV     DPTR,#046A1H
005B EF                MOV     A,R7
005C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 425
005D 22                RET     
                                           ; SOURCE LINE # 427
005E         ?C0041:
                                           ; SOURCE LINE # 428
005E 7B0C              MOV     R3,#0CH
0060 7A01              MOV     R2,#01H
0062 790B              MOV     R1,#0BH
0064 120000      E     LCALL   _cyread8
0067 9046A1            MOV     DPTR,#046A1H
006A EF                MOV     A,R7
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 429
006C 22                RET     
                                           ; SOURCE LINE # 431
006D         ?C0042:
                                           ; SOURCE LINE # 432
006D 7B0C              MOV     R3,#0CH
006F 7A01              MOV     R2,#01H
0071 7989              MOV     R1,#089H
0073 120000      E     LCALL   _cyread8
0076 9046A1            MOV     DPTR,#046A1H
0079 EF                MOV     A,R7
007A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 433
007B 22                RET     
                                           ; SOURCE LINE # 435
007C         ?C0043:
                                           ; SOURCE LINE # 436
007C 7B0C              MOV     R3,#0CH
007E 7A01              MOV     R2,#01H
0080 790C              MOV     R1,#0CH
0082 120000      E     LCALL   _cyread8
0085 9046A1            MOV     DPTR,#046A1H
0088 EF                MOV     A,R7
0089 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 437
008A 22                RET     
                                           ; SOURCE LINE # 445
008B         ?C0044:
                                           ; SOURCE LINE # 446
008B 7B0C              MOV     R3,#0CH
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 60  

008D 7A01              MOV     R2,#01H
008F 790F              MOV     R1,#0FH
0091 120000      E     LCALL   _cyread8
0094 9046A1            MOV     DPTR,#046A1H
0097 EF                MOV     A,R7
0098 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 449
0099 900000      R     MOV     DPTR,#usbPowerOn
009C E0                MOVX    A,@DPTR
009D B4010D            CJNE    A,#01H,?C0048
                                           ; SOURCE LINE # 450
                                           ; SOURCE LINE # 452
00A0 906009            MOV     DPTR,#06009H
00A3 E0                MOVX    A,@DPTR
00A4 4402              ORL     A,#02H
00A6 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 453
                                           ; SOURCE LINE # 454
00A7 22                RET     
                                           ; SOURCE LINE # 456
00A8         ?C0046:
                                           ; SOURCE LINE # 457
00A8 7F00              MOV     R7,#00H
00AA 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 458
                                           ; SOURCE LINE # 459
                                           ; SOURCE LINE # 461
00AD         ?C0048:
00AD 22                RET     
             ; FUNCTION _CyIMO_SetTrimValue (END)

             ; FUNCTION _CyIMO_SetFreq (BEGIN)
                                           ; SOURCE LINE # 498
0000 900000      R     MOV     DPTR,#freq
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 499
                                           ; SOURCE LINE # 510
0005 904200            MOV     DPTR,#04200H
0008 E0                MOVX    A,@DPTR
0009 5407              ANL     A,#07H
000B 900000      R     MOV     DPTR,#currentFreq
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 513
000F 900000      R     MOV     DPTR,#freq
0012 E0                MOVX    A,@DPTR
0013 FF                MOV     R7,A
0014 B40806            CJNE    A,#08H,?C0049
0017 7E03              MOV     R6,#03H
0019 7F03              MOV     R7,#03H
001B 8000              SJMP    ?C0050
001D         ?C0049:
001D         ?C0050:
001D 900000      R     MOV     DPTR,#nextFreq
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 515
0022 900000      R     MOV     DPTR,#currentFreq
0025 E0                MOVX    A,@DPTR
0026 14                DEC     A
0027 6018              JZ      ?C0053
0029 14                DEC     A
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 61  

002A 601D              JZ      ?C0054
002C 14                DEC     A
002D 6022              JZ      ?C0055
002F 14                DEC     A
0030 6026              JZ      ?C0056
0032 14                DEC     A
0033 602B              JZ      ?C0057
0035 2405              ADD     A,#05H
0037 702F              JNZ     ?C0058
                                           ; SOURCE LINE # 516
                                           ; SOURCE LINE # 517
0039         ?C0052:
                                           ; SOURCE LINE # 518
0039 900000      R     MOV     DPTR,#currentFreq
003C 7402              MOV     A,#02H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 519
003F 802C              SJMP    ?C0051
                                           ; SOURCE LINE # 521
0041         ?C0053:
                                           ; SOURCE LINE # 522
0041 900000      R     MOV     DPTR,#currentFreq
0044 7401              MOV     A,#01H
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
0047 8024              SJMP    ?C0051
                                           ; SOURCE LINE # 525
0049         ?C0054:
                                           ; SOURCE LINE # 526
0049 900000      R     MOV     DPTR,#currentFreq
004C 7403              MOV     A,#03H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 527
004F 801C              SJMP    ?C0051
                                           ; SOURCE LINE # 529
0051         ?C0055:
                                           ; SOURCE LINE # 530
0051 E4                CLR     A
0052 900000      R     MOV     DPTR,#currentFreq
0055 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 531
0056 8015              SJMP    ?C0051
                                           ; SOURCE LINE # 533
0058         ?C0056:
                                           ; SOURCE LINE # 534
0058 900000      R     MOV     DPTR,#currentFreq
005B 7404              MOV     A,#04H
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 535
005E 800D              SJMP    ?C0051
                                           ; SOURCE LINE # 537
0060         ?C0057:
                                           ; SOURCE LINE # 538
0060 900000      R     MOV     DPTR,#currentFreq
0063 7405              MOV     A,#05H
0065 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 539
0066 8005              SJMP    ?C0051
                                           ; SOURCE LINE # 547
0068         ?C0058:
                                           ; SOURCE LINE # 548
0068 7F00              MOV     R7,#00H
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 62  

006A 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 549
                                           ; SOURCE LINE # 550
006D         ?C0051:
                                           ; SOURCE LINE # 552
006D 900000      R     MOV     DPTR,#currentFreq
0070 E0                MOVX    A,@DPTR
0071 FF                MOV     R7,A
0072 A3                INC     DPTR
0073 E0                MOVX    A,@DPTR
0074 C3                CLR     C
0075 9F                SUBB    A,R7
0076 4008              JC      ?C0060
                                           ; SOURCE LINE # 553
                                           ; SOURCE LINE # 555
0078 900000      R     MOV     DPTR,#freq
007B E0                MOVX    A,@DPTR
007C FF                MOV     R7,A
007D 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 556
0080         ?C0060:
                                           ; SOURCE LINE # 559
0080 900000      R     MOV     DPTR,#freq
0083 E0                MOVX    A,@DPTR
0084 120000      E     LCALL   ?C?CCASE
0087 0000        R     DW      ?C0062
0089 00                DB      00H
008A 0000        R     DW      ?C0063
008C 01                DB      01H
008D 0000        R     DW      ?C0064
008F 02                DB      02H
0090 0000        R     DW      ?C0065
0092 03                DB      03H
0093 0000        R     DW      ?C0066
0095 04                DB      04H
0096 0000        R     DW      ?C0067
0098 05                DB      05H
0099 0000        R     DW      ?C0068
009B 08                DB      08H
009C 0000              DW      00H
009E 0000        R     DW      ?C0069
                                           ; SOURCE LINE # 560
                                           ; SOURCE LINE # 561
00A0         ?C0062:
                                           ; SOURCE LINE # 563
00A0 904200            MOV     DPTR,#04200H
00A3 E0                MOVX    A,@DPTR
00A4 54F8              ANL     A,#0F8H
00A6 4403              ORL     A,#03H
00A8 54BF              ANL     A,#0BFH
00AA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 564
00AB 804D              SJMP    ?C0061
                                           ; SOURCE LINE # 566
00AD         ?C0063:
                                           ; SOURCE LINE # 568
00AD 904200            MOV     DPTR,#04200H
00B0 E0                MOVX    A,@DPTR
00B1 54F8              ANL     A,#0F8H
00B3 4401              ORL     A,#01H
00B5 54BF              ANL     A,#0BFH
00B7 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 63  

                                           ; SOURCE LINE # 569
00B8 8040              SJMP    ?C0061
                                           ; SOURCE LINE # 571
00BA         ?C0064:
                                           ; SOURCE LINE # 573
00BA 904200            MOV     DPTR,#04200H
00BD E0                MOVX    A,@DPTR
00BE 54B8              ANL     A,#0B8H
00C0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 574
00C1 8037              SJMP    ?C0061
                                           ; SOURCE LINE # 576
00C3         ?C0065:
                                           ; SOURCE LINE # 578
00C3 904200            MOV     DPTR,#04200H
00C6 E0                MOVX    A,@DPTR
00C7 54F8              ANL     A,#0F8H
00C9 4402              ORL     A,#02H
00CB 54BF              ANL     A,#0BFH
00CD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 579
00CE 802A              SJMP    ?C0061
                                           ; SOURCE LINE # 581
00D0         ?C0066:
                                           ; SOURCE LINE # 583
00D0 904200            MOV     DPTR,#04200H
00D3 E0                MOVX    A,@DPTR
00D4 54F8              ANL     A,#0F8H
00D6 4404              ORL     A,#04H
00D8 54BF              ANL     A,#0BFH
00DA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 584
00DB 801D              SJMP    ?C0061
                                           ; SOURCE LINE # 586
00DD         ?C0067:
                                           ; SOURCE LINE # 588
00DD 904200            MOV     DPTR,#04200H
00E0 E0                MOVX    A,@DPTR
00E1 54F8              ANL     A,#0F8H
00E3 4405              ORL     A,#05H
00E5 54BF              ANL     A,#0BFH
00E7 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 589
00E8 8010              SJMP    ?C0061
                                           ; SOURCE LINE # 598
00EA         ?C0068:
                                           ; SOURCE LINE # 599
00EA 904200            MOV     DPTR,#04200H
00ED E0                MOVX    A,@DPTR
00EE 54F8              ANL     A,#0F8H
00F0 4442              ORL     A,#042H
00F2 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 601
00F3 8005              SJMP    ?C0061
                                           ; SOURCE LINE # 603
00F5         ?C0069:
                                           ; SOURCE LINE # 604
00F5 7F00              MOV     R7,#00H
00F7 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 605
                                           ; SOURCE LINE # 606
00FA         ?C0061:
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 64  

                                           ; SOURCE LINE # 609
00FA 900000      R     MOV     DPTR,#freq
00FD E0                MOVX    A,@DPTR
00FE B40805            CJNE    A,#08H,?C0071
                                           ; SOURCE LINE # 610
                                           ; SOURCE LINE # 611
0101 120000      R     LCALL   CyIMO_EnableDoubler
                                           ; SOURCE LINE # 612
0104 8003              SJMP    ?C0072
0106         ?C0071:
                                           ; SOURCE LINE # 614
                                           ; SOURCE LINE # 615
0106 120000      R     LCALL   CyIMO_DisableDoubler
                                           ; SOURCE LINE # 616
0109         ?C0072:
                                           ; SOURCE LINE # 618
0109 900000      R     MOV     DPTR,#currentFreq
010C E0                MOVX    A,@DPTR
010D FF                MOV     R7,A
010E A3                INC     DPTR
010F E0                MOVX    A,@DPTR
0110 C3                CLR     C
0111 9F                SUBB    A,R7
0112 5008              JNC     ?C0074
                                           ; SOURCE LINE # 619
                                           ; SOURCE LINE # 621
0114 900000      R     MOV     DPTR,#freq
0117 E0                MOVX    A,@DPTR
0118 FF                MOV     R7,A
0119 120000      R     LCALL   _CyIMO_SetTrimValue
                                           ; SOURCE LINE # 622
                                           ; SOURCE LINE # 623
011C         ?C0074:
011C 22                RET     
             ; FUNCTION _CyIMO_SetFreq (END)

             ; FUNCTION _CyIMO_SetSource (BEGIN)
                                           ; SOURCE LINE # 653
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 654
                                           ; SOURCE LINE # 655
0000 EF                MOV     A,R7
0001 6024              JZ      ?C0078
0003 14                DEC     A
0004 6012              JZ      ?C0077
0006 14                DEC     A
0007 7026              JNZ     ?C0079
                                           ; SOURCE LINE # 656
                                           ; SOURCE LINE # 657
0009         ?C0076:
                                           ; SOURCE LINE # 658
0009 904000            MOV     DPTR,#04000H
000C E0                MOVX    A,@DPTR
000D 54BF              ANL     A,#0BFH
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 659
0010 904200            MOV     DPTR,#04200H
0013 E0                MOVX    A,@DPTR
0014 4420              ORL     A,#020H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 660
0017 22                RET     
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 65  

                                           ; SOURCE LINE # 662
0018         ?C0077:
                                           ; SOURCE LINE # 663
0018 904000            MOV     DPTR,#04000H
001B E0                MOVX    A,@DPTR
001C 4440              ORL     A,#040H
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 664
001F 904200            MOV     DPTR,#04200H
0022 E0                MOVX    A,@DPTR
0023 4420              ORL     A,#020H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 665
0026 22                RET     
                                           ; SOURCE LINE # 667
0027         ?C0078:
                                           ; SOURCE LINE # 668
0027 904200            MOV     DPTR,#04200H
002A E0                MOVX    A,@DPTR
002B 54DF              ANL     A,#0DFH
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 669
002E 22                RET     
                                           ; SOURCE LINE # 671
002F         ?C0079:
                                           ; SOURCE LINE # 673
002F 7F00              MOV     R7,#00H
0031 120000      R     LCALL   _?CyHalt
                                           ; SOURCE LINE # 674
                                           ; SOURCE LINE # 675
                                           ; SOURCE LINE # 676
0034         ?C0081:
0034 22                RET     
             ; FUNCTION _CyIMO_SetSource (END)

             ; FUNCTION CyIMO_EnableDoubler (BEGIN)
                                           ; SOURCE LINE # 694
                                           ; SOURCE LINE # 695
                                           ; SOURCE LINE # 697
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 4410              ORL     A,#010H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 698
0007 22                RET     
             ; FUNCTION CyIMO_EnableDoubler (END)

             ; FUNCTION CyIMO_DisableDoubler (BEGIN)
                                           ; SOURCE LINE # 715
                                           ; SOURCE LINE # 716
                                           ; SOURCE LINE # 717
0000 904200            MOV     DPTR,#04200H
0003 E0                MOVX    A,@DPTR
0004 54EF              ANL     A,#0EFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 718
0007 22                RET     
             ; FUNCTION CyIMO_DisableDoubler (END)

             ; FUNCTION _CyMasterClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 750
;---- Variable 'source' assigned to Register 'R7' ----
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 66  

                                           ; SOURCE LINE # 751
                                           ; SOURCE LINE # 753
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904005            MOV     DPTR,#04005H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 754
000C 22                RET     
             ; FUNCTION _CyMasterClk_SetSource (END)

             ; FUNCTION _CyMasterClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 785
;---- Variable 'divider' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 786
                                           ; SOURCE LINE # 787
0000 904004            MOV     DPTR,#04004H
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 788
0005 22                RET     
             ; FUNCTION _CyMasterClk_SetDivider (END)

             ; FUNCTION _CyBusClk_Internal_SetDivider (BEGIN)
                                           ; SOURCE LINE # 807
;---- Variable 'divider' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 808
                                           ; SOURCE LINE # 810
0000 904014            MOV     DPTR,#04014H
0003 E0                MOVX    A,@DPTR
0004 54F0              ANL     A,#0F0H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 811
0007 904010            MOV     DPTR,#04010H
000A E4                CLR     A
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 814
000C 904008            MOV     DPTR,#04008H
000F E0                MOVX    A,@DPTR
0010 4480              ORL     A,#080H
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 817
0013 EF                MOV     A,R7
0014 904002            MOV     DPTR,#04002H
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 818
0018 EE                MOV     A,R6
0019 A3                INC     DPTR
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 827
001B 904001            MOV     DPTR,#04001H
001E E0                MOVX    A,@DPTR
001F 4401              ORL     A,#01H
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 828
0022 22                RET     
             ; FUNCTION _CyBusClk_Internal_SetDivider (END)

             ; FUNCTION _CyBusClk_SetDivider (BEGIN)
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 67  

                                           ; SOURCE LINE # 854
0000 900000      R     MOV     DPTR,#divider
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 855
                                           ; SOURCE LINE # 860
0008 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R1' ----
000B A907              MOV     R1,AR7
                                           ; SOURCE LINE # 863
000D 904007            MOV     DPTR,#04007H
0010 E0                MOVX    A,@DPTR
0011 7F00              MOV     R7,#00H
0013 FE                MOV     R6,A
;---- Variable 'busClkDiv' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 864
0014 904006            MOV     DPTR,#04006H
0017 E0                MOVX    A,@DPTR
0018 FD                MOV     R5,A
0019 EE                MOV     A,R6
001A ED                MOV     A,R5
001B FF                MOV     R7,A
                                           ; SOURCE LINE # 866
001C 900000      R     MOV     DPTR,#divider
001F E0                MOVX    A,@DPTR
0020 7002              JNZ     ?C0195
0022 A3                INC     DPTR
0023 E0                MOVX    A,@DPTR
0024         ?C0195:
0024 6004              JZ      ?C0088
0026 EF                MOV     A,R7
0027 4E                ORL     A,R6
0028 703F              JNZ     ?C0087
002A         ?C0088:
                                           ; SOURCE LINE # 867
                                           ; SOURCE LINE # 869
002A 904004            MOV     DPTR,#04004H
002D E0                MOVX    A,@DPTR
;---- Variable 'masterClkDiv' assigned to Register 'R5' ----
002E FD                MOV     R5,A
                                           ; SOURCE LINE # 871
002F C3                CLR     C
0030 9407              SUBB    A,#07H
0032 5005              JNC     ?C0089
                                           ; SOURCE LINE # 872
                                           ; SOURCE LINE # 874
0034 7F07              MOV     R7,#07H
0036 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 875
0039         ?C0089:
                                           ; SOURCE LINE # 877
0039 900000      R     MOV     DPTR,#divider
003C E0                MOVX    A,@DPTR
003D FE                MOV     R6,A
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 4E                ORL     A,R6
0042 700C              JNZ     ?C0090
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 68  

                                           ; SOURCE LINE # 878
                                           ; SOURCE LINE # 880
0044 904008            MOV     DPTR,#04008H
0047 E0                MOVX    A,@DPTR
0048 4440              ORL     A,#040H
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 881
004B 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 882
004E 8012              SJMP    ?C0091
0050         ?C0090:
                                           ; SOURCE LINE # 884
                                           ; SOURCE LINE # 885
0050 900000      R     MOV     DPTR,#divider
0053 E0                MOVX    A,@DPTR
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
0057 FF                MOV     R7,A
0058 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 886
005B 904008            MOV     DPTR,#04008H
005E E0                MOVX    A,@DPTR
005F 54BF              ANL     A,#0BFH
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 887
0062         ?C0091:
                                           ; SOURCE LINE # 890
0062 AF05              MOV     R7,AR5
0064 120000      R     LCALL   _CyMasterClk_SetDivider
                                           ; SOURCE LINE # 891
0067 800B              SJMP    ?C0092
0069         ?C0087:
                                           ; SOURCE LINE # 893
                                           ; SOURCE LINE # 894
0069 900000      R     MOV     DPTR,#divider
006C E0                MOVX    A,@DPTR
006D FE                MOV     R6,A
006E A3                INC     DPTR
006F E0                MOVX    A,@DPTR
0070 FF                MOV     R7,A
0071 120000      R     LCALL   _CyBusClk_Internal_SetDivider
                                           ; SOURCE LINE # 895
0074         ?C0092:
                                           ; SOURCE LINE # 897
0074 AF01              MOV     R7,AR1
0076 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 898
0079 22                RET     
             ; FUNCTION _CyBusClk_SetDivider (END)

             ; FUNCTION _CyCpuClk_SetDivider (BEGIN)
                                           ; SOURCE LINE # 927
;---- Variable 'divider' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 928
                                           ; SOURCE LINE # 930
0000 EF                MOV     A,R7
0001 C4                SWAP    A
0002 54F0              ANL     A,#0F0H
0004 FF                MOV     R7,A
0005 904005            MOV     DPTR,#04005H
0008 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 69  

0009 540F              ANL     A,#0FH
000B 4F                ORL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 931
000D 22                RET     
             ; FUNCTION _CyCpuClk_SetDivider (END)

             ; FUNCTION _CyUsbClk_SetSource (BEGIN)
                                           ; SOURCE LINE # 954
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 955
                                           ; SOURCE LINE # 956
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904009            MOV     DPTR,#04009H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 958
000C 22                RET     
             ; FUNCTION _CyUsbClk_SetSource (END)

             ; FUNCTION CyILO_Start1K (BEGIN)
                                           ; SOURCE LINE # 979
                                           ; SOURCE LINE # 980
                                           ; SOURCE LINE # 982
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4402              ORL     A,#02H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 983
0007 22                RET     
             ; FUNCTION CyILO_Start1K (END)

             ; FUNCTION CyILO_Stop1K (BEGIN)
                                           ; SOURCE LINE # 1007
                                           ; SOURCE LINE # 1008
                                           ; SOURCE LINE # 1010
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1011
0007 22                RET     
             ; FUNCTION CyILO_Stop1K (END)

             ; FUNCTION CyILO_Start100K (BEGIN)
                                           ; SOURCE LINE # 1028
                                           ; SOURCE LINE # 1029
                                           ; SOURCE LINE # 1030
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1031
0007 22                RET     
             ; FUNCTION CyILO_Start100K (END)

             ; FUNCTION CyILO_Stop100K (BEGIN)
                                           ; SOURCE LINE # 1048
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 70  

                                           ; SOURCE LINE # 1049
                                           ; SOURCE LINE # 1050
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1051
0007 22                RET     
             ; FUNCTION CyILO_Stop100K (END)

             ; FUNCTION CyILO_Enable33K (BEGIN)
                                           ; SOURCE LINE # 1071
                                           ; SOURCE LINE # 1072
                                           ; SOURCE LINE # 1074
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 4420              ORL     A,#020H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1075
0007 22                RET     
             ; FUNCTION CyILO_Enable33K (END)

             ; FUNCTION CyILO_Disable33K (BEGIN)
                                           ; SOURCE LINE # 1095
                                           ; SOURCE LINE # 1096
                                           ; SOURCE LINE # 1097
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 54DF              ANL     A,#0DFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1098
0007 22                RET     
             ; FUNCTION CyILO_Disable33K (END)

             ; FUNCTION _CyILO_SetSource (BEGIN)
                                           ; SOURCE LINE # 1119
;---- Variable 'source' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1120
                                           ; SOURCE LINE # 1122
0000 EF                MOV     A,R7
0001 25E0              ADD     A,ACC
0003 25E0              ADD     A,ACC
0005 540C              ANL     A,#0CH
0007 FF                MOV     R7,A
0008 904000            MOV     DPTR,#04000H
000B E0                MOVX    A,@DPTR
000C 54F3              ANL     A,#0F3H
000E 4F                ORL     A,R7
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1123
0010 22                RET     
             ; FUNCTION _CyILO_SetSource (END)

             ; FUNCTION _CyILO_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1143
;---- Variable 'mode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1144
                                           ; SOURCE LINE # 1148
0000 904300            MOV     DPTR,#04300H
0003 E0                MOVX    A,@DPTR
0004 FE                MOV     R6,A
;---- Variable 'state' assigned to Register 'R6' ----
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 71  

                                           ; SOURCE LINE # 1151
0005 EF                MOV     A,R7
0006 6006              JZ      ?C0103
                                           ; SOURCE LINE # 1152
                                           ; SOURCE LINE # 1153
0008 EE                MOV     A,R6
0009 4410              ORL     A,#010H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1154
000C 8007              SJMP    ?C0104
000E         ?C0103:
                                           ; SOURCE LINE # 1156
                                           ; SOURCE LINE # 1157
000E EE                MOV     A,R6
000F 54EF              ANL     A,#0EFH
0011 904300            MOV     DPTR,#04300H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1158
0015         ?C0104:
                                           ; SOURCE LINE # 1161
0015 AF06              MOV     R7,AR6
0017 EE                MOV     A,R6
0018 5410              ANL     A,#010H
001A FF                MOV     R7,A
001B E4                CLR     A
001C C4                SWAP    A
001D F8                MOV     R0,A
001E 54F0              ANL     A,#0F0H
0020 C8                XCH     A,R0
0021 68                XRL     A,R0
0022 EF                MOV     A,R7
0023 C4                SWAP    A
0024 540F              ANL     A,#0FH
0026 48                ORL     A,R0
0027 FF                MOV     R7,A
                                           ; SOURCE LINE # 1162
0028         ?C0105:
0028 22                RET     
             ; FUNCTION _CyILO_SetPowerMode (END)

             ; FUNCTION CyXTAL_32KHZ_Start (BEGIN)
                                           ; SOURCE LINE # 1179
                                           ; SOURCE LINE # 1180
                                           ; SOURCE LINE # 1183
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1184
0006 904698            MOV     DPTR,#04698H
0009 7403              MOV     A,#03H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1185
000C 904309            MOV     DPTR,#04309H
000F E0                MOVX    A,@DPTR
0010 54F3              ANL     A,#0F3H
0012 4404              ORL     A,#04H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1189
0015 904308            MOV     DPTR,#04308H
0018 E0                MOVX    A,@DPTR
0019 4404              ORL     A,#04H
001B F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 72  

                                           ; SOURCE LINE # 1193
001C E0                MOVX    A,@DPTR
001D 4401              ORL     A,#01H
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1195
0020 900000      R     MOV     DPTR,#i
0023 7403              MOV     A,#03H
0025 F0                MOVX    @DPTR,A
0026 A3                INC     DPTR
0027 74E8              MOV     A,#0E8H
0029 F0                MOVX    @DPTR,A
002A         ?C0106:
002A D3                SETB    C
002B 900000      R     MOV     DPTR,#i+01H
002E E0                MOVX    A,@DPTR
002F 9400              SUBB    A,#00H
0031 900000      R     MOV     DPTR,#i
0034 E0                MOVX    A,@DPTR
0035 9400              SUBB    A,#00H
0037 4020              JC      ?C0110
                                           ; SOURCE LINE # 1196
                                           ; SOURCE LINE # 1197
0039 120000      R     LCALL   CyXTAL_32KHZ_ReadStatus
003C EF                MOV     A,R7
003D 30E506            JNB     ACC.5,?C0109
                                           ; SOURCE LINE # 1198
                                           ; SOURCE LINE # 1200
0040 E4                CLR     A
0041 FF                MOV     R7,A
0042 120000      R     LCALL   _CyXTAL_32KHZ_SetPowerMode
                                           ; SOURCE LINE # 1202
0045 22                RET     
                                           ; SOURCE LINE # 1203
0046         ?C0109:
                                           ; SOURCE LINE # 1204
0046 7F01              MOV     R7,#01H
0048 7E00              MOV     R6,#00H
004A 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1205
004D 900000      R     MOV     DPTR,#i
0050 74FF              MOV     A,#0FFH
0052 F5F0              MOV     B,A
0054 120000      E     LCALL   ?C?IILDX
0057 80D1              SJMP    ?C0106
                                           ; SOURCE LINE # 1206
0059         ?C0110:
0059 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Start (END)

             ; FUNCTION CyXTAL_32KHZ_Stop (BEGIN)
                                           ; SOURCE LINE # 1223
                                           ; SOURCE LINE # 1224
                                           ; SOURCE LINE # 1225
0000 90430A            MOV     DPTR,#0430AH
0003 74F3              MOV     A,#0F3H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1226
0006 904698            MOV     DPTR,#04698H
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1227
000B 904309            MOV     DPTR,#04309H
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 73  

000E E0                MOVX    A,@DPTR
000F 54F3              ANL     A,#0F3H
0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1229
0014 904308            MOV     DPTR,#04308H
0017 E0                MOVX    A,@DPTR
0018 54FC              ANL     A,#0FCH
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1232
001B E0                MOVX    A,@DPTR
001C 54FB              ANL     A,#0FBH
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1234
001F 22                RET     
             ; FUNCTION CyXTAL_32KHZ_Stop (END)

             ; FUNCTION CyXTAL_32KHZ_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1254
                                           ; SOURCE LINE # 1255
                                           ; SOURCE LINE # 1256
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5420              ANL     A,#020H
0006 FF                MOV     R7,A
                                           ; SOURCE LINE # 1257
0007         ?C0112:
0007 22                RET     
             ; FUNCTION CyXTAL_32KHZ_ReadStatus (END)

             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (BEGIN)
                                           ; SOURCE LINE # 1278
;---- Variable 'mode' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1279
                                           ; SOURCE LINE # 1280
0000 904308            MOV     DPTR,#04308H
0003 E0                MOVX    A,@DPTR
0004 5402              ANL     A,#02H
0006 6004              JZ      ?C0113
0008 7E01              MOV     R6,#01H
000A 8002              SJMP    ?C0114
000C         ?C0113:
000C 7E00              MOV     R6,#00H
000E         ?C0114:
000E 900000      R     MOV     DPTR,#state
0011 EE                MOV     A,R6
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1282
0013 90430A            MOV     DPTR,#0430AH
0016 74F3              MOV     A,#0F3H
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1284
0019 EF                MOV     A,R7
001A 6401              XRL     A,#01H
001C 7025              JNZ     ?C0115
                                           ; SOURCE LINE # 1285
                                           ; SOURCE LINE # 1287
001E 904698            MOV     DPTR,#04698H
0021 04                INC     A
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1288
0023 7F0A              MOV     R7,#0AH
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 74  

0025 7E00              MOV     R6,#00H
0027 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1289
002A 904309            MOV     DPTR,#04309H
002D E0                MOVX    A,@DPTR
002E 54F3              ANL     A,#0F3H
0030 4408              ORL     A,#08H
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1291
0033 7F14              MOV     R7,#014H
0035 7E00              MOV     R6,#00H
0037 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1292
003A 904308            MOV     DPTR,#04308H
003D E0                MOVX    A,@DPTR
003E 4402              ORL     A,#02H
0040 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1293
0041 801D              SJMP    ?C0116
0043         ?C0115:
                                           ; SOURCE LINE # 1295
                                           ; SOURCE LINE # 1297
0043 904698            MOV     DPTR,#04698H
0046 7406              MOV     A,#06H
0048 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1298
0049 7F0A              MOV     R7,#0AH
004B 7E00              MOV     R6,#00H
004D 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1299
0050 904309            MOV     DPTR,#04309H
0053 E0                MOVX    A,@DPTR
0054 54F3              ANL     A,#0F3H
0056 4404              ORL     A,#04H
0058 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1301
0059 904308            MOV     DPTR,#04308H
005C E0                MOVX    A,@DPTR
005D 54FD              ANL     A,#0FDH
005F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1302
0060         ?C0116:
                                           ; SOURCE LINE # 1304
0060 900000      R     MOV     DPTR,#state
0063 E0                MOVX    A,@DPTR
0064 FF                MOV     R7,A
                                           ; SOURCE LINE # 1305
0065         ?C0117:
0065 22                RET     
             ; FUNCTION _CyXTAL_32KHZ_SetPowerMode (END)

             ; FUNCTION _CyXTAL_Start (BEGIN)
                                           ; SOURCE LINE # 1344
;---- Variable 'wait' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1345
                                           ; SOURCE LINE # 1346
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#status
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1347
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 75  

0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1355
0008 904210            MOV     DPTR,#04210H
000B E0                MOVX    A,@DPTR
000C 4401              ORL     A,#01H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1358
000F EF                MOV     A,R7
0010 D3                SETB    C
0011 9400              SUBB    A,#00H
0013 5003              JNC     $ + 5H
0015 020000      R     LJMP    ?C0118
                                           ; SOURCE LINE # 1359
                                           ; SOURCE LINE # 1361
0018 904300            MOV     DPTR,#04300H
001B E0                MOVX    A,@DPTR
001C 900000      R     MOV     DPTR,#iloEnableState
001F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1362
0020 904380            MOV     DPTR,#04380H
0023 E0                MOVX    A,@DPTR
0024 900000      R     MOV     DPTR,#pmTwCfg0Tmp
0027 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1363
0028 904382            MOV     DPTR,#04382H
002B E0                MOVX    A,@DPTR
002C 900000      R     MOV     DPTR,#pmTwCfg2Tmp
002F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1366
0030 7F18              MOV     R7,#018H
0032 120000      E     LCALL   _CyPmFtwSetInterval
                                           ; SOURCE LINE # 1367
0035 900000      R     MOV     DPTR,#status
0038 7410              MOV     A,#010H
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1370
003B         ?C0119:
003B 900000      R     MOV     DPTR,#timeout
003E E0                MOVX    A,@DPTR
003F D3                SETB    C
0040 9400              SUBB    A,#00H
0042 403B              JC      ?C0120
                                           ; SOURCE LINE # 1371
                                           ; SOURCE LINE # 1373
0044 904210            MOV     DPTR,#04210H
0047 E0                MOVX    A,@DPTR
0048 FF                MOV     R7,A
                                           ; SOURCE LINE # 1376
0049 900000      R     MOV     DPTR,#count
004C 7404              MOV     A,#04H
004E F0                MOVX    @DPTR,A
004F         ?C0122:
004F 900000      R     MOV     DPTR,#count
0052 E0                MOVX    A,@DPTR
0053 D3                SETB    C
0054 9400              SUBB    A,#00H
0056 4011              JC      ?C0123
                                           ; SOURCE LINE # 1377
0058         ?C0125:
                                           ; SOURCE LINE # 1378
0058 7F01              MOV     R7,#01H
005A 120000      E     LCALL   _CyPmReadStatus
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 76  

005D EF                MOV     A,R7
005E 30E0F7            JNB     ACC.0,?C0125
                                           ; SOURCE LINE # 1379
                                           ; SOURCE LINE # 1381
0061         ?C0126:
                                           ; SOURCE LINE # 1382
0061         ?C0124:
0061 900000      R     MOV     DPTR,#count
0064 E0                MOVX    A,@DPTR
0065 14                DEC     A
0066 F0                MOVX    @DPTR,A
0067 80E6              SJMP    ?C0122
0069         ?C0123:
                                           ; SOURCE LINE # 1389
0069 904210            MOV     DPTR,#04210H
006C E0                MOVX    A,@DPTR
006D 5480              ANL     A,#080H
006F 7006              JNZ     ?C0121
                                           ; SOURCE LINE # 1390
                                           ; SOURCE LINE # 1391
0071 900000      R     MOV     DPTR,#status
0074 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1392
0075 8008              SJMP    ?C0120
                                           ; SOURCE LINE # 1393
                                           ; SOURCE LINE # 1394
0077         ?C0121:
0077 900000      R     MOV     DPTR,#timeout
007A E0                MOVX    A,@DPTR
007B 14                DEC     A
007C F0                MOVX    @DPTR,A
007D 80BC              SJMP    ?C0119
007F         ?C0120:
                                           ; SOURCE LINE # 1398
007F 900000      R     MOV     DPTR,#iloEnableState
0082 E0                MOVX    A,@DPTR
0083 5404              ANL     A,#04H
0085 7003              JNZ     ?C0128
                                           ; SOURCE LINE # 1399
                                           ; SOURCE LINE # 1400
0087 120000      R     LCALL   CyILO_Stop100K
                                           ; SOURCE LINE # 1401
008A         ?C0128:
                                           ; SOURCE LINE # 1402
008A 900000      R     MOV     DPTR,#pmTwCfg0Tmp
008D E0                MOVX    A,@DPTR
008E 904380            MOV     DPTR,#04380H
0091 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1403
0092 900000      R     MOV     DPTR,#pmTwCfg2Tmp
0095 E0                MOVX    A,@DPTR
0096 904382            MOV     DPTR,#04382H
0099 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1404
009A         ?C0118:
                                           ; SOURCE LINE # 1406
009A 900000      R     MOV     DPTR,#status
009D E0                MOVX    A,@DPTR
009E FF                MOV     R7,A
                                           ; SOURCE LINE # 1407
009F         ?C0129:
009F 22                RET     
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 77  

             ; FUNCTION _CyXTAL_Start (END)

             ; FUNCTION CyXTAL_Stop (BEGIN)
                                           ; SOURCE LINE # 1424
                                           ; SOURCE LINE # 1425
                                           ; SOURCE LINE # 1427
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1428
0007 22                RET     
             ; FUNCTION CyXTAL_Stop (END)

             ; FUNCTION CyXTAL_EnableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1446
                                           ; SOURCE LINE # 1447
                                           ; SOURCE LINE # 1449
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1450
0007 22                RET     
             ; FUNCTION CyXTAL_EnableErrStatus (END)

             ; FUNCTION CyXTAL_DisableErrStatus (BEGIN)
                                           ; SOURCE LINE # 1468
                                           ; SOURCE LINE # 1469
                                           ; SOURCE LINE # 1471
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 4404              ORL     A,#04H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1472
0007 22                RET     
             ; FUNCTION CyXTAL_DisableErrStatus (END)

             ; FUNCTION CyXTAL_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1492
                                           ; SOURCE LINE # 1493
                                           ; SOURCE LINE # 1498
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 5480              ANL     A,#080H
0006 6004              JZ      ?C0133
0008 7F01              MOV     R7,#01H
000A 8002              SJMP    ?C0134
000C         ?C0133:
000C 7F00              MOV     R7,#00H
000E         ?C0134:
                                           ; SOURCE LINE # 1499
000E         ?C0135:
000E 22                RET     
             ; FUNCTION CyXTAL_ReadStatus (END)

             ; FUNCTION CyXTAL_EnableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1519
                                           ; SOURCE LINE # 1520
                                           ; SOURCE LINE # 1521
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 78  

0004 4440              ORL     A,#040H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1522
0007 22                RET     
             ; FUNCTION CyXTAL_EnableFaultRecovery (END)

             ; FUNCTION CyXTAL_DisableFaultRecovery (BEGIN)
                                           ; SOURCE LINE # 1541
                                           ; SOURCE LINE # 1542
                                           ; SOURCE LINE # 1543
0000 904210            MOV     DPTR,#04210H
0003 E0                MOVX    A,@DPTR
0004 54BF              ANL     A,#0BFH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1544
0007 22                RET     
             ; FUNCTION CyXTAL_DisableFaultRecovery (END)

             ; FUNCTION _CyXTAL_SetStartup (BEGIN)
                                           ; SOURCE LINE # 1567
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1568
                                           ; SOURCE LINE # 1569
0000 EF                MOV     A,R7
0001 541F              ANL     A,#01FH
0003 FF                MOV     R7,A
0004 904212            MOV     DPTR,#04212H
0007 E0                MOVX    A,@DPTR
0008 54E0              ANL     A,#0E0H
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1571
000C 22                RET     
             ; FUNCTION _CyXTAL_SetStartup (END)

             ; FUNCTION _CyXTAL_SetFbVoltage (BEGIN)
                                           ; SOURCE LINE # 1591
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1592
                                           ; SOURCE LINE # 1593
0000 EF                MOV     A,R7
0001 540F              ANL     A,#0FH
0003 FF                MOV     R7,A
0004 904213            MOV     DPTR,#04213H
0007 E0                MOVX    A,@DPTR
0008 54F0              ANL     A,#0F0H
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1595
000C 22                RET     
             ; FUNCTION _CyXTAL_SetFbVoltage (END)

             ; FUNCTION _CyXTAL_SetWdVoltage (BEGIN)
                                           ; SOURCE LINE # 1614
;---- Variable 'setting' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1615
                                           ; SOURCE LINE # 1617
0000 EF                MOV     A,R7
0001 C4                SWAP    A
0002 5470              ANL     A,#070H
0004 FF                MOV     R7,A
0005 904213            MOV     DPTR,#04213H
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 79  

0008 E0                MOVX    A,@DPTR
0009 548F              ANL     A,#08FH
000B 4F                ORL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1618
000D 22                RET     
             ; FUNCTION _CyXTAL_SetWdVoltage (END)

             ; FUNCTION _?CyHalt (BEGIN)
                                           ; SOURCE LINE # 1635
0000 90FFFF            MOV     DPTR,#0FFFFH
0003 120000      E     LCALL   ?C?ADDXBP
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1637
                                           ; SOURCE LINE # 1638
                                           ; SOURCE LINE # 1640
0008         ?C0141:
                                           ; SOURCE LINE # 1647
0008 9046EA            MOV     DPTR,#046EAH
000B 7401              MOV     A,#01H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1649
000E 900001            MOV     DPTR,#01H
0011 120000      E     LCALL   ?C?ADDXBP
0014 22                RET     
             ; FUNCTION _?CyHalt (END)

             ; FUNCTION CySoftwareReset (BEGIN)
                                           ; SOURCE LINE # 1666
                                           ; SOURCE LINE # 1667
                                           ; SOURCE LINE # 1668
0000 9046F6            MOV     DPTR,#046F6H
0003 E0                MOVX    A,@DPTR
0004 4401              ORL     A,#01H
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1669
0007 22                RET     
             ; FUNCTION CySoftwareReset (END)

             ; FUNCTION _?CyDelay (BEGIN)
                                           ; SOURCE LINE # 1692
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
0009         ?C0144:
                                           ; SOURCE LINE # 1694
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F 120000      E     LCALL   ?C?LLDXDATA
0012 D3                SETB    C
0013 EF                MOV     A,R7
0014 9400              SUBB    A,#00H
0016 EE                MOV     A,R6
0017 9480              SUBB    A,#080H
0019 402E              JC      ?C0145
                                           ; SOURCE LINE # 1695
                                           ; SOURCE LINE # 1700
001B 900000      R     MOV     DPTR,#cydelay_32k_ms
001E 120000      E     LCALL   ?C?LLDXDATA
0021 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1701
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 80  

0024 850083      E     MOV     DPH,?C_XBP
0027 850082      E     MOV     DPL,?C_XBP+01H
002A C083              PUSH    DPH
002C C082              PUSH    DPL
002E 120000      E     LCALL   ?C?LLDXDATA
0031 E4                CLR     A
0032 2F                ADD     A,R7
0033 FF                MOV     R7,A
0034 EE                MOV     A,R6
0035 3480              ADDC    A,#080H
0037 FE                MOV     R6,A
0038 ED                MOV     A,R5
0039 34FF              ADDC    A,#0FFH
003B FD                MOV     R5,A
003C EC                MOV     A,R4
003D 34FF              ADDC    A,#0FFH
003F FC                MOV     R4,A
0040 D082              POP     DPL
0042 D083              POP     DPH
0044 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1702
0047 80C0              SJMP    ?C0144
0049         ?C0145:
                                           ; SOURCE LINE # 1704
0049 900000      R     MOV     DPTR,#cydelay_freq_khz
004C 120000      E     LCALL   ?C?LLDXDATA
004F 850083      E     MOV     DPH,?C_XBP
0052 850082      E     MOV     DPL,?C_XBP+01H
0055 120000      E     LCALL   ?C?LLDXDATA0
0058 120000      E     LCALL   ?C?LMUL
005B 120000      E     LCALL   _CyDelayCycles
                                           ; SOURCE LINE # 1705
005E 900004            MOV     DPTR,#04H
0061 120000      E     LCALL   ?C?ADDXBP
0064 22                RET     
             ; FUNCTION _?CyDelay (END)

             ; FUNCTION _?CyDelayFreq (BEGIN)
                                           ; SOURCE LINE # 1763
0000 90FFFC            MOV     DPTR,#0FFFCH
0003 120000      E     LCALL   ?C?ADDXBP
0006 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1765
0009 850083      E     MOV     DPH,?C_XBP
000C 850082      E     MOV     DPL,?C_XBP+01H
000F 120000      E     LCALL   ?C?LLDXDATA
0012 EF                MOV     A,R7
0013 4E                ORL     A,R6
0014 6011              JZ      ?C0147
                                           ; SOURCE LINE # 1766
                                           ; SOURCE LINE # 1767
0016 850083      E     MOV     DPH,?C_XBP
0019 850082      E     MOV     DPL,?C_XBP+01H
001C 120000      E     LCALL   ?C?LLDXDATA
001F 900000      R     MOV     DPTR,#cydelay_freq_hz
0022 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1768
0025 800E              SJMP    ?C0148
0027         ?C0147:
                                           ; SOURCE LINE # 1770
                                           ; SOURCE LINE # 1771
0027 7F00              MOV     R7,#00H
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 81  

0029 7E36              MOV     R6,#036H
002B 7D6E              MOV     R5,#06EH
002D 7C01              MOV     R4,#01H
002F 900000      R     MOV     DPTR,#cydelay_freq_hz
0032 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1772
0035         ?C0148:
                                           ; SOURCE LINE # 1774
0035 900000      R     MOV     DPTR,#cydelay_freq_hz
0038 120000      E     LCALL   ?C?LLDXDATA
003B EF                MOV     A,R7
003C 243F              ADD     A,#03FH
003E FF                MOV     R7,A
003F EE                MOV     A,R6
0040 3442              ADDC    A,#042H
0042 FE                MOV     R6,A
0043 ED                MOV     A,R5
0044 340F              ADDC    A,#0FH
0046 FD                MOV     R5,A
0047 E4                CLR     A
0048 3C                ADDC    A,R4
0049 FC                MOV     R4,A
004A 7B40              MOV     R3,#040H
004C 7A42              MOV     R2,#042H
004E 790F              MOV     R1,#0FH
0050 7800              MOV     R0,#00H
0052 120000      E     LCALL   ?C?ULDIV
0055 900000      R     MOV     DPTR,#cydelay_freq_mhz
0058 EF                MOV     A,R7
0059 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1775
005A A3                INC     DPTR
005B 120000      E     LCALL   ?C?LLDXDATA
005E EF                MOV     A,R7
005F 24E7              ADD     A,#0E7H
0061 FF                MOV     R7,A
0062 EE                MOV     A,R6
0063 3403              ADDC    A,#03H
0065 FE                MOV     R6,A
0066 E4                CLR     A
0067 3D                ADDC    A,R5
0068 FD                MOV     R5,A
0069 E4                CLR     A
006A 3C                ADDC    A,R4
006B FC                MOV     R4,A
006C E4                CLR     A
006D 7BE8              MOV     R3,#0E8H
006F 7A03              MOV     R2,#03H
0071 F9                MOV     R1,A
0072 F8                MOV     R0,A
0073 120000      E     LCALL   ?C?ULDIV
0076 900000      R     MOV     DPTR,#cydelay_freq_khz
0079 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1776
007C E4                CLR     A
007D FF                MOV     R7,A
007E 7E80              MOV     R6,#080H
0080 FD                MOV     R5,A
0081 FC                MOV     R4,A
0082 900000      R     MOV     DPTR,#cydelay_freq_khz
0085 120000      E     LCALL   ?C?LLDXDATA0
0088 120000      E     LCALL   ?C?LMUL
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 82  

008B 900000      R     MOV     DPTR,#cydelay_32k_ms
008E 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1777
0091 900004            MOV     DPTR,#04H
0094 120000      E     LCALL   ?C?ADDXBP
0097 22                RET     
             ; FUNCTION _?CyDelayFreq (END)

             ; FUNCTION _CyWdtStart (BEGIN)
                                           ; SOURCE LINE # 1826
;---- Variable 'lpMode' assigned to Register 'R5' ----
;---- Variable 'ticks' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 1827
                                           ; SOURCE LINE # 1829
0000 EF                MOV     A,R7
0001 5403              ANL     A,#03H
0003 FF                MOV     R7,A
0004 904383            MOV     DPTR,#04383H
0007 E0                MOVX    A,@DPTR
0008 54FC              ANL     A,#0FCH
000A 4F                ORL     A,R7
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1832
000C E0                MOVX    A,@DPTR
000D 4480              ORL     A,#080H
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1833
0010 E0                MOVX    A,@DPTR
0011 547F              ANL     A,#07FH
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1837
0014 AF05              MOV     R7,AR5
0016 EF                MOV     A,R7
0017 C4                SWAP    A
0018 33                RLC     A
0019 5460              ANL     A,#060H
001B FF                MOV     R7,A
001C E0                MOVX    A,@DPTR
001D 549F              ANL     A,#09FH
001F 4F                ORL     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1840
0021 E0                MOVX    A,@DPTR
0022 4410              ORL     A,#010H
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1841
0025 22                RET     
             ; FUNCTION _CyWdtStart (END)

             ; FUNCTION CyWdtClear (BEGIN)
                                           ; SOURCE LINE # 1858
                                           ; SOURCE LINE # 1859
                                           ; SOURCE LINE # 1860
0000 904384            MOV     DPTR,#04384H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1861
0006 22                RET     
             ; FUNCTION CyWdtClear (END)

             ; FUNCTION _CyVdLvDigitEnable (BEGIN)
                                           ; SOURCE LINE # 1886
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 83  

0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
;---- Variable 'threshold' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 1887
                                           ; SOURCE LINE # 1888
0005 9044C8            MOV     DPTR,#044C8H
0008 7401              MOV     A,#01H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1890
000B 9046F7            MOV     DPTR,#046F7H
000E E0                MOVX    A,@DPTR
000F 54BF              ANL     A,#0BFH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1893
0012 9046F4            MOV     DPTR,#046F4H
0015 E0                MOVX    A,@DPTR
0016 54F0              ANL     A,#0F0H
0018 FF                MOV     R7,A
0019 ED                MOV     A,R5
001A 540F              ANL     A,#0FH
001C 4F                ORL     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1894
001E A3                INC     DPTR
001F E0                MOVX    A,@DPTR
0020 4401              ORL     A,#01H
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1897
0023 7F01              MOV     R7,#01H
0025 7E00              MOV     R6,#00H
0027 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1899
002A 9046FA            MOV     DPTR,#046FAH
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
                                           ; SOURCE LINE # 1901
002F 900000      R     MOV     DPTR,#reset
0032 E0                MOVX    A,@DPTR
0033 6009              JZ      ?C0152
                                           ; SOURCE LINE # 1902
                                           ; SOURCE LINE # 1903
0035 9046F7            MOV     DPTR,#046F7H
0038 E0                MOVX    A,@DPTR
0039 4440              ORL     A,#040H
003B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1904
003C 8007              SJMP    ?C0153
003E         ?C0152:
                                           ; SOURCE LINE # 1906
                                           ; SOURCE LINE # 1907
003E 9046F7            MOV     DPTR,#046F7H
0041 E0                MOVX    A,@DPTR
0042 54BF              ANL     A,#0BFH
0044 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1908
0045         ?C0153:
                                           ; SOURCE LINE # 1910
0045 9044D8            MOV     DPTR,#044D8H
0048 7401              MOV     A,#01H
004A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1911
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 84  

004B 9044C0            MOV     DPTR,#044C0H
004E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1912
004F 22                RET     
             ; FUNCTION _CyVdLvDigitEnable (END)

             ; FUNCTION _CyVdLvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 1936
0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
;---- Variable 'threshold' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 1937
                                           ; SOURCE LINE # 1938
0005 9044C8            MOV     DPTR,#044C8H
0008 7401              MOV     A,#01H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1940
000B 9046F7            MOV     DPTR,#046F7H
000E E0                MOVX    A,@DPTR
000F 547F              ANL     A,#07FH
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1942
0012 AF05              MOV     R7,AR5
0014 EF                MOV     A,R7
0015 C4                SWAP    A
0016 54F0              ANL     A,#0F0H
0018 FF                MOV     R7,A
0019 9046F4            MOV     DPTR,#046F4H
001C E0                MOVX    A,@DPTR
001D 540F              ANL     A,#0FH
001F 4F                ORL     A,R7
0020 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1943
0021 A3                INC     DPTR
0022 E0                MOVX    A,@DPTR
0023 4402              ORL     A,#02H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1946
0026 7F01              MOV     R7,#01H
0028 7E00              MOV     R6,#00H
002A 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 1948
002D 9046FA            MOV     DPTR,#046FAH
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
                                           ; SOURCE LINE # 1950
0032 900000      R     MOV     DPTR,#reset
0035 E0                MOVX    A,@DPTR
0036 6009              JZ      ?C0155
                                           ; SOURCE LINE # 1951
                                           ; SOURCE LINE # 1952
0038 9046F7            MOV     DPTR,#046F7H
003B E0                MOVX    A,@DPTR
003C 4480              ORL     A,#080H
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1953
003F 8007              SJMP    ?C0156
0041         ?C0155:
                                           ; SOURCE LINE # 1955
                                           ; SOURCE LINE # 1956
0041 9046F7            MOV     DPTR,#046F7H
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 85  

0044 E0                MOVX    A,@DPTR
0045 547F              ANL     A,#07FH
0047 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1957
0048         ?C0156:
                                           ; SOURCE LINE # 1959
0048 9044D8            MOV     DPTR,#044D8H
004B 7401              MOV     A,#01H
004D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1960
004E 9044C0            MOV     DPTR,#044C0H
0051 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1961
0052 22                RET     
             ; FUNCTION _CyVdLvAnalogEnable (END)

             ; FUNCTION CyVdLvDigitDisable (BEGIN)
                                           ; SOURCE LINE # 1979
                                           ; SOURCE LINE # 1980
                                           ; SOURCE LINE # 1981
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FE              ANL     A,#0FEH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1983
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 54BF              ANL     A,#0BFH
000D F0                MOVX    @DPTR,A
000E         ?C0158:
                                           ; SOURCE LINE # 1985
000E 9046FA            MOV     DPTR,#046FAH
0011 E0                MOVX    A,@DPTR
0012 5407              ANL     A,#07H
0014 70F8              JNZ     ?C0158
                                           ; SOURCE LINE # 1986
                                           ; SOURCE LINE # 1988
0016         ?C0159:
                                           ; SOURCE LINE # 1989
0016         ?C0160:
0016 22                RET     
             ; FUNCTION CyVdLvDigitDisable (END)

             ; FUNCTION CyVdLvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 2007
                                           ; SOURCE LINE # 2008
                                           ; SOURCE LINE # 2009
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FD              ANL     A,#0FDH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2011
0007 9046F7            MOV     DPTR,#046F7H
000A E0                MOVX    A,@DPTR
000B 547F              ANL     A,#07FH
000D F0                MOVX    @DPTR,A
000E         ?C0161:
                                           ; SOURCE LINE # 2013
000E 9046FA            MOV     DPTR,#046FAH
0011 E0                MOVX    A,@DPTR
0012 5407              ANL     A,#07H
0014 70F8              JNZ     ?C0161
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 86  

                                           ; SOURCE LINE # 2014
                                           ; SOURCE LINE # 2016
0016         ?C0162:
                                           ; SOURCE LINE # 2017
0016         ?C0163:
0016 22                RET     
             ; FUNCTION CyVdLvAnalogDisable (END)

             ; FUNCTION CyVdHvAnalogEnable (BEGIN)
                                           ; SOURCE LINE # 2035
                                           ; SOURCE LINE # 2036
                                           ; SOURCE LINE # 2037
0000 9044C8            MOV     DPTR,#044C8H
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2039
0006 9046F7            MOV     DPTR,#046F7H
0009 E0                MOVX    A,@DPTR
000A 547F              ANL     A,#07FH
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2041
000D 9046F5            MOV     DPTR,#046F5H
0010 E0                MOVX    A,@DPTR
0011 4404              ORL     A,#04H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2044
0014 7F01              MOV     R7,#01H
0016 7E00              MOV     R6,#00H
0018 120000      E     LCALL   _CyDelayUs
                                           ; SOURCE LINE # 2046
001B 9046FA            MOV     DPTR,#046FAH
001E E0                MOVX    A,@DPTR
001F FF                MOV     R7,A
                                           ; SOURCE LINE # 2048
0020 9044D8            MOV     DPTR,#044D8H
0023 7401              MOV     A,#01H
0025 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2049
0026 9044C0            MOV     DPTR,#044C0H
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2050
002A 22                RET     
             ; FUNCTION CyVdHvAnalogEnable (END)

             ; FUNCTION CyVdHvAnalogDisable (BEGIN)
                                           ; SOURCE LINE # 2068
                                           ; SOURCE LINE # 2069
                                           ; SOURCE LINE # 2070
0000 9046F5            MOV     DPTR,#046F5H
0003 E0                MOVX    A,@DPTR
0004 54FB              ANL     A,#0FBH
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2071
0007 22                RET     
             ; FUNCTION CyVdHvAnalogDisable (END)

             ; FUNCTION _CyVdStickyStatus (BEGIN)
                                           ; SOURCE LINE # 2094
;---- Variable 'mask' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2095
                                           ; SOURCE LINE # 2098
0000 9046FA            MOV     DPTR,#046FAH
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 87  

0003 E0                MOVX    A,@DPTR
0004 FE                MOV     R6,A
;---- Variable 'status' assigned to Register 'R6' ----
                                           ; SOURCE LINE # 2099
0005 E0                MOVX    A,@DPTR
0006 FD                MOV     R5,A
0007 EF                MOV     A,R7
0008 F4                CPL     A
0009 FF                MOV     R7,A
000A ED                MOV     A,R5
000B 5F                ANL     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2101
000D AF06              MOV     R7,AR6
                                           ; SOURCE LINE # 2102
000F         ?C0166:
000F 22                RET     
             ; FUNCTION _CyVdStickyStatus (END)

             ; FUNCTION CyVdRealTimeStatus (BEGIN)
                                           ; SOURCE LINE # 2123
                                           ; SOURCE LINE # 2124
                                           ; SOURCE LINE # 2128
0000 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2129
0003 9046FC            MOV     DPTR,#046FCH
0006 E0                MOVX    A,@DPTR
0007 900000      R     MOV     DPTR,#vdFlagsState
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2130
000B 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2132
000E 900000      R     MOV     DPTR,#vdFlagsState
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
                                           ; SOURCE LINE # 2133
0013         ?C0167:
0013 22                RET     
             ; FUNCTION CyVdRealTimeStatus (END)

             ; FUNCTION CyDisableInts (BEGIN)
                                           ; SOURCE LINE # 2150
                                           ; SOURCE LINE # 2151
                                           ; SOURCE LINE # 2155
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#interruptState
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2160
0008 9044C8            MOV     DPTR,#044C8H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D E4                CLR     A
000E FC                MOV     R4,A
000F FD                MOV     R5,A
0010 FE                MOV     R6,A
0011 900000      R     MOV     DPTR,#intState
0014 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2161
0017 900000      R     MOV     DPTR,#intState
001A 120000      E     LCALL   ?C?LLDXDATA0
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 88  

001D C000              PUSH    AR0
001F 9044C9            MOV     DPTR,#044C9H
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 E4                CLR     A
0025 FC                MOV     R4,A
0026 FD                MOV     R5,A
0027 FE                MOV     R6,A
0028 7808              MOV     R0,#08H
002A 120000      E     LCALL   ?C?LSHL
002D D000              POP     AR0
002F 120000      E     LCALL   ?C?LOR
0032 900000      R     MOV     DPTR,#intState
0035 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2162
0038 900000      R     MOV     DPTR,#intState
003B 120000      E     LCALL   ?C?LLDXDATA0
003E C000              PUSH    AR0
0040 9044CA            MOV     DPTR,#044CAH
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 E4                CLR     A
0046 FC                MOV     R4,A
0047 FD                MOV     R5,A
0048 FE                MOV     R6,A
0049 7810              MOV     R0,#010H
004B 120000      E     LCALL   ?C?LSHL
004E D000              POP     AR0
0050 120000      E     LCALL   ?C?LOR
0053 900000      R     MOV     DPTR,#intState
0056 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2163
0059 900000      R     MOV     DPTR,#intState
005C 120000      E     LCALL   ?C?LLDXDATA0
005F C000              PUSH    AR0
0061 9044CB            MOV     DPTR,#044CBH
0064 E0                MOVX    A,@DPTR
0065 FF                MOV     R7,A
0066 E4                CLR     A
0067 FC                MOV     R4,A
0068 FD                MOV     R5,A
0069 FE                MOV     R6,A
006A 7818              MOV     R0,#018H
006C 120000      E     LCALL   ?C?LSHL
006F D000              POP     AR0
0071 120000      E     LCALL   ?C?LOR
0074 900000      R     MOV     DPTR,#intState
0077 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2167
007A 9044C8            MOV     DPTR,#044C8H
007D 74FF              MOV     A,#0FFH
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2168
0080 A3                INC     DPTR
0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2169
0082 A3                INC     DPTR
0083 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2170
0084 A3                INC     DPTR
0085 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2182
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 89  

0086 900000      R     MOV     DPTR,#interruptState
0089 E0                MOVX    A,@DPTR
008A FF                MOV     R7,A
008B 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2184
008E 900000      R     MOV     DPTR,#intState
0091 120000      E     LCALL   ?C?LLDXDATA
                                           ; SOURCE LINE # 2185
0094         ?C0168:
0094 22                RET     
             ; FUNCTION CyDisableInts (END)

             ; FUNCTION _CyEnableInts (BEGIN)
                                           ; SOURCE LINE # 2202
0000 900000      R     MOV     DPTR,#mask
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 2203
                                           ; SOURCE LINE # 2207
0006 120000      E     LCALL   CyEnterCriticalSection
;---- Variable 'interruptState' assigned to Register 'R3' ----
0009 AB07              MOV     R3,AR7
                                           ; SOURCE LINE # 2212
000B 900000      R     MOV     DPTR,#mask
000E 120000      E     LCALL   ?C?LLDXDATA
0011 7818              MOV     R0,#018H
0013 120000      E     LCALL   ?C?ULSHR
0016 9044C3            MOV     DPTR,#044C3H
0019 EF                MOV     A,R7
001A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2213
001B 900000      R     MOV     DPTR,#mask
001E 120000      E     LCALL   ?C?LLDXDATA
0021 7810              MOV     R0,#010H
0023 120000      E     LCALL   ?C?ULSHR
0026 9044C2            MOV     DPTR,#044C2H
0029 EF                MOV     A,R7
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2214
002B 900000      R     MOV     DPTR,#mask
002E 120000      E     LCALL   ?C?LLDXDATA
0031 7808              MOV     R0,#08H
0033 120000      E     LCALL   ?C?ULSHR
0036 9044C1            MOV     DPTR,#044C1H
0039 EF                MOV     A,R7
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2215
003B 900000      R     MOV     DPTR,#mask
003E 120000      E     LCALL   ?C?LLDXDATA
0041 9044C0            MOV     DPTR,#044C0H
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2223
0046 AF03              MOV     R7,AR3
0048 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 2225
004B 22                RET     
             ; FUNCTION _CyEnableInts (END)

             ; FUNCTION _CyIntSetVector (BEGIN)
                                           ; SOURCE LINE # 2508
0000 900000      R     MOV     DPTR,#address
0003 EC                MOV     A,R4
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 90  

0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
0008 900000      R     MOV     DPTR,#number
000B EF                MOV     A,R7
000C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2509
                                           ; SOURCE LINE # 2510
                                           ; SOURCE LINE # 2512
000D D3                SETB    C
000E 941F              SUBB    A,#01FH
0010 5002              JNC     ?C0171
0012 8001              SJMP    ?C0172
0014         ?C0171:
0014 C3                CLR     C
0015         ?C0172:
0015 4005              JC      ?C0170
0017 7F00              MOV     R7,#00H
0019 120000      R     LCALL   _?CyHalt
001C         ?C0170:
                                           ; SOURCE LINE # 2515
001C 900000      R     MOV     DPTR,#number
001F E0                MOVX    A,@DPTR
0020 541F              ANL     A,#01FH
0022 25E0              ADD     A,ACC
0024 FF                MOV     R7,A
0025 E4                CLR     A
0026 33                RLC     A
0027 FE                MOV     R6,A
0028 E4                CLR     A
0029 2F                ADD     A,R7
002A FF                MOV     R7,A
002B EE                MOV     A,R6
002C 3444              ADDC    A,#044H
002E FA                MOV     R2,A
002F A907              MOV     R1,AR7
0031 7B01              MOV     R3,#01H
0033 120000      E     LCALL   _cyread16_nodpx
0036 900000      R     MOV     DPTR,#oldIsr
0039 EE                MOV     A,R6
003A F0                MOVX    @DPTR,A
003B A3                INC     DPTR
003C EF                MOV     A,R7
003D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2519
003E 900000      R     MOV     DPTR,#number
0041 E0                MOVX    A,@DPTR
0042 75F002            MOV     B,#02H
0045 A4                MUL     AB
0046 2400              ADD     A,#00H
0048 FF                MOV     R7,A
0049 E5F0              MOV     A,B
004B 3444              ADDC    A,#044H
004D FA                MOV     R2,A
004E A907              MOV     R1,AR7
0050 7B01              MOV     R3,#01H
0052 A3                INC     DPTR
0053 E0                MOVX    A,@DPTR
0054 FE                MOV     R6,A
0055 A3                INC     DPTR
0056 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 91  

0057 FF                MOV     R7,A
0058 FD                MOV     R5,A
0059 AC06              MOV     R4,AR6
005B 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 2521
005E 900000      R     MOV     DPTR,#oldIsr
0061 E0                MOVX    A,@DPTR
0062 FE                MOV     R6,A
0063 A3                INC     DPTR
0064 E0                MOVX    A,@DPTR
0065 FF                MOV     R7,A
                                           ; SOURCE LINE # 2522
0066         ?C0173:
0066 22                RET     
             ; FUNCTION _CyIntSetVector (END)

             ; FUNCTION _CyIntGetVector (BEGIN)
                                           ; SOURCE LINE # 2539
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2540
                                           ; SOURCE LINE # 2541
0005 D3                SETB    C
0006 941F              SUBB    A,#01FH
0008 5002              JNC     ?C0175
000A 8001              SJMP    ?C0176
000C         ?C0175:
000C C3                CLR     C
000D         ?C0176:
000D 4005              JC      ?C0174
000F 7F00              MOV     R7,#00H
0011 120000      R     LCALL   _?CyHalt
0014         ?C0174:
                                           ; SOURCE LINE # 2543
0014 900000      R     MOV     DPTR,#number
0017 E0                MOVX    A,@DPTR
0018 541F              ANL     A,#01FH
001A 25E0              ADD     A,ACC
001C FF                MOV     R7,A
001D E4                CLR     A
001E 33                RLC     A
001F FE                MOV     R6,A
0020 E4                CLR     A
0021 2F                ADD     A,R7
0022 FF                MOV     R7,A
0023 EE                MOV     A,R6
0024 3444              ADDC    A,#044H
0026 FA                MOV     R2,A
0027 A907              MOV     R1,AR7
0029 7B01              MOV     R3,#01H
002B 120000      E     LCALL   _cyread16_nodpx
                                           ; SOURCE LINE # 2545
002E         ?C0177:
002E 22                RET     
             ; FUNCTION _CyIntGetVector (END)

             ; FUNCTION _CyIntSetPriority (BEGIN)
                                           ; SOURCE LINE # 2563
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 92  

0005 A3                INC     DPTR
0006 ED                MOV     A,R5
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2564
                                           ; SOURCE LINE # 2565
0008 D3                SETB    C
0009 9407              SUBB    A,#07H
000B 5002              JNC     ?C0179
000D 8001              SJMP    ?C0180
000F         ?C0179:
000F C3                CLR     C
0010         ?C0180:
0010 4005              JC      ?C0178
0012 7F00              MOV     R7,#00H
0014 120000      R     LCALL   _?CyHalt
0017         ?C0178:
                                           ; SOURCE LINE # 2567
0017 900000      R     MOV     DPTR,#number
001A E0                MOVX    A,@DPTR
001B D3                SETB    C
001C 941F              SUBB    A,#01FH
001E 5002              JNC     ?C0182
0020 8001              SJMP    ?C0183
0022         ?C0182:
0022 C3                CLR     C
0023         ?C0183:
0023 4005              JC      ?C0181
0025 7F00              MOV     R7,#00H
0027 120000      R     LCALL   _?CyHalt
002A         ?C0181:
                                           ; SOURCE LINE # 2569
002A 900000      R     MOV     DPTR,#priority
002D E0                MOVX    A,@DPTR
002E 5407              ANL     A,#07H
0030 75F020            MOV     B,#020H
0033 A4                MUL     AB
0034 FF                MOV     R7,A
0035 900000      R     MOV     DPTR,#number
0038 E0                MOVX    A,@DPTR
0039 541F              ANL     A,#01FH
003B 2480              ADD     A,#080H
003D F582              MOV     DPL,A
003F E4                CLR     A
0040 3444              ADDC    A,#044H
0042 F583              MOV     DPH,A
0044 EF                MOV     A,R7
0045 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2571
0046 22                RET     
             ; FUNCTION _CyIntSetPriority (END)

             ; FUNCTION _CyIntGetPriority (BEGIN)
                                           ; SOURCE LINE # 2588
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2589
                                           ; SOURCE LINE # 2590
                                           ; SOURCE LINE # 2592
0005 D3                SETB    C
0006 941F              SUBB    A,#01FH
0008 5002              JNC     ?C0186
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 93  

000A 8001              SJMP    ?C0187
000C         ?C0186:
000C C3                CLR     C
000D         ?C0187:
000D 4005              JC      ?C0185
000F 7F00              MOV     R7,#00H
0011 120000      R     LCALL   _?CyHalt
0014         ?C0185:
                                           ; SOURCE LINE # 2594
0014 900000      R     MOV     DPTR,#number
0017 E0                MOVX    A,@DPTR
0018 541F              ANL     A,#01FH
001A 2480              ADD     A,#080H
001C F582              MOV     DPL,A
001E E4                CLR     A
001F 3444              ADDC    A,#044H
0021 F583              MOV     DPH,A
0023 E0                MOVX    A,@DPTR
0024 FF                MOV     R7,A
0025 C4                SWAP    A
0026 13                RRC     A
0027 5407              ANL     A,#07H
0029 FF                MOV     R7,A
;---- Variable 'priority' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 2596
                                           ; SOURCE LINE # 2597
002A         ?C0188:
002A 22                RET     
             ; FUNCTION _CyIntGetPriority (END)

             ; FUNCTION _CyIntGetState (BEGIN)
                                           ; SOURCE LINE # 2614
0000 900000      R     MOV     DPTR,#number
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 2615
                                           ; SOURCE LINE # 2616
                                           ; SOURCE LINE # 2618
0005 D3                SETB    C
0006 941F              SUBB    A,#01FH
0008 5002              JNC     ?C0190
000A 8001              SJMP    ?C0191
000C         ?C0190:
000C C3                CLR     C
000D         ?C0191:
000D 4005              JC      ?C0189
000F 7F00              MOV     R7,#00H
0011 120000      R     LCALL   _?CyHalt
0014         ?C0189:
                                           ; SOURCE LINE # 2621
0014 900000      R     MOV     DPTR,#number
0017 E0                MOVX    A,@DPTR
0018 FD                MOV     R5,A
0019 541F              ANL     A,#01FH
001B 7E00              MOV     R6,#00H
001D 7803              MOV     R0,#03H
001F         ?C0196:
001F CE                XCH     A,R6
0020 C3                CLR     C
0021 13                RRC     A
0022 CE                XCH     A,R6
0023 13                RRC     A
C51 COMPILER V9.51   CYLIB                                                                 03/27/2015 19:22:28 PAGE 94  

0024 D8F9              DJNZ    R0,?C0196
0026 24C0              ADD     A,#0C0H
0028 FF                MOV     R7,A
0029 EE                MOV     A,R6
002A 3444              ADDC    A,#044H
002C FE                MOV     R6,A
;---- Variable 'stateReg' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 2624
002D ED                MOV     A,R5
002E 5407              ANL     A,#07H
0030 FD                MOV     R5,A
0031 7401              MOV     A,#01H
0033 A805              MOV     R0,AR5
0035 08                INC     R0
0036 8002              SJMP    ?C0198
0038         ?C0197:
0038 C3                CLR     C
0039 33                RLC     A
003A         ?C0198:
003A D8FC              DJNZ    R0,?C0197
003C FD                MOV     R5,A
003D 8F82              MOV     DPL,R7
003F 8E83              MOV     DPH,R6
0041 E0                MOVX    A,@DPTR
0042 5D                ANL     A,R5
0043 6004              JZ      ?C0192
0045 7F01              MOV     R7,#01H
0047 8002              SJMP    ?C0193
0049         ?C0192:
0049 7F00              MOV     R7,#00H
004B         ?C0193:
                                           ; SOURCE LINE # 2625
004B         ?C0194:
004B 22                RET     
             ; FUNCTION _CyIntGetState (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2923    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14      48
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
