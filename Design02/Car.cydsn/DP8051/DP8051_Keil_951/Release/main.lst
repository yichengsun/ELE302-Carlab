C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Release\main.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.1\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\main.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,.\Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\DP8051\DP8051_Keil_951
                    -\Release/main.lst) CD OT(8,SIZE) OJ(.\DP8051\DP8051_Keil_951\Release\main.obj)

line level    source

*** MESSAGE C286 IN LINE 0 OF (null): license limits optimization to level 5
   1          #include <project.h>
   2          #include <stdio.h>
   3          
   4          #define INCH_PER_MAGNET 1.58
   5          #define SEC_PER_PERIOD 357.914
   6          
   7          #define THREE_FT_DUTY 900
   8          #define CENTER_DUTY 4560 
   9          #define CENTER_LINE 780
  10          
  11          #define Kp 1250
  12          #define Ki 120
  13          #define Kd 0
  14          
  15          #define Kp_steer 2.25
  16          #define Ki_steer 0
  17          #define Kd_steer 30000
  18          
  19          double gExpectedSpeed = 3.5;
  20          double gTotalTraveled = 0;
  21          
  22          double gprev_HE_count = 0;
  23          int gfirst_HE_read = 1;
  24          int gspeedMeasurements = 0;
  25          double gcurSpeed = 0;
  26          double speedCounts[5];
  27          double gki_speederror = 0;
  28          double gki_steererror = 0;
  29          int glinepos = 0;
  30          double gsteer_dutycycle = 0;
  31          
  32          int gnum_line_reads = 0;
  33          double gblack_pos_first_diff = 0;
  34          double gblack_pos_second_diff = 0;
  35          double gblack_totalpos_diff = 0;
  36          int gCounterNReads = 0;
  37          int gblackcount = 0;
  38          uint32 gfirstpos = 0;
  39          uint32 gsecondpos = 0;
  40          uint32 gthirdpos = 0;
  41          uint32 gfourthpos = 0;
  42          uint32 gcaptures = 0;
  43          int count = 0;
  44          int gsteer_error_prev = 0;
  45          
  46          uint8 direction = 0;
  47          
  48          int gONOFF = 0;
  49          int gcurr_dir = 0;
  50          /*
  51          void updateSteering() {
  52              double error;   
C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 2   

  53              double duty_cycle_buffer;
  54              uint16 duty_cycle;
  55              char buffer[10];
  56              
  57              
  58              //Calculate the error for feedback 
  59              error = gblack_totalpos_diff - CENTER_LINE;
  60              
  61              // left max 3600; center 4560; right max 5800
  62              //gki_steererror = gki_steererror+error*.000011;
  63              gsteer_dutycycle = CENTER_DUTY - Kp_steer*error - Kd_steer*(gsteer_error_prev-error)/395372.0;
  64              gsteer_error_prev=error;
  65              
  66              if (gblack_totalpos_diff > CENTER_LINE){
  67                  gExpectedSpeed = 5.5 - (gblack_totalpos_diff-CENTER_LINE)/240.0*2;
  68              }
  69              else {
  70                  gExpectedSpeed = 5.5 - (CENTER_LINE-gblack_totalpos_diff)/310.0*2;
  71              }
  72              //Have in place error checking to prevent sporadic  behavior
  73              if (gsteer_dutycycle > 5700){
  74                  gsteer_dutycycle = 5800;   
  75              }
  76              if (gsteer_dutycycle <= 3700) {
  77                  gsteer_dutycycle = 3550;
  78              }
  79              
  80              STEERING_PWM_WriteCompare(gsteer_dutycycle);
  81          }
  82          
  83          CY_ISR(UPDATE_STEER_inter) {
  84              updateSteering();
  85          }
  86          
  87          CY_ISR(SEC_TIL_BLACK_TIMER_inter) {
  88              char buffer[15];
  89              gfirstpos = SEC_TIL_BLACK_TIMER_ReadCapture();
  90              gsecondpos = SEC_TIL_BLACK_TIMER_ReadCapture();
  91              SEC_TIL_BLACK_TIMER_ClearFIFO();
  92          
  93              gblack_totalpos_diff = (double)(gsecondpos - gfirstpos);
  94              if (gblack_totalpos_diff < 280){
  95                  gblack_totalpos_diff = 280;
  96              }
  97              else if (gblack_totalpos_diff > 1200){
  98                  gblack_totalpos_diff = 1200;   
  99              }
 100          
 101              SEC_TIL_BLACK_TIMER_ReadStatusRegister();
 102              }
 103          */
 104          
 105          /*
 106          //Averages out speed for the last wheel rotation to even out magnet spacing
 107          double getSpeedAvg(double speeds[]){
 108              double counter = 0;
 109              uint32 i = 0;
 110              uint32 size = 5;
 111              if (gspeedMeasurements < 5) {
 112                  size = gspeedMeasurements;
 113              }
 114              for (i = 0; i < size; i++){
C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 3   

 115                  counter = counter + speeds[i];   
 116              }
 117              return counter/(double)size;
 118          }
 119          
 120          //Grab current speed via unit conversions
 121          double getCurSpeed(){
 122              double current_Speed = 0;
 123              //average clock tix b/w two magnets in one rotation
 124              current_Speed = getSpeedAvg(speedCounts);
 125              //average sec elapsed b/w two magnets
 126              current_Speed = (double)current_Speed/HE_TIMER_ReadPeriod() * SEC_PER_PERIOD;
 127              //average speed b/w two magnets
 128              current_Speed = (double)INCH_PER_MAGNET/current_Speed/12;
 129              // return (double)current_Speed;
 130              return current_Speed;
 131          }
 132          
 133          
 134          //Interrupt on each hall effect sensor passing by to update speed and PWM duty cycle
 135          CY_ISR(HE_inter) {
 136              double curr_HE_count = 0;
 137              double time_diff = 0;
 138              double time_diff_s = 0;
 139              double error = 0;
 140              double PID_speed = 0;
 141              char buffer[15];
 142              double duty_cycle_buffer = 0;
 143              uint16 duty_cycle = 0;
 144              gTotalTraveled += INCH_PER_MAGNET;
 145              
 146              //Special first time read   
 147              if (gfirst_HE_read == 1) {
 148                  gprev_HE_count = HE_TIMER_ReadCounter();
 149                  gfirst_HE_read = 0;
 150              } 
 151              else {
 152                  curr_HE_count = HE_TIMER_ReadCounter();
 153                  if (gprev_HE_count < curr_HE_count) {
 154                      gprev_HE_count = gprev_HE_count + HE_TIMER_ReadPeriod();
 155                  }
 156          
 157                  //Calculate the time difference between each magnet passing by
 158                  time_diff = gprev_HE_count - curr_HE_count;
 159                  time_diff_s = time_diff/HE_TIMER_ReadPeriod() * SEC_PER_PERIOD;
 160                  
 161                  speedCounts[gspeedMeasurements%5] = time_diff;
 162                  gspeedMeasurements++;
 163                  gcurSpeed = getCurSpeed();
 164                  gprev_HE_count = curr_HE_count;
 165                  //Calculate the error for feedback 
 166                  error = gExpectedSpeed - gcurSpeed;
 167                  //Accumulate past errors for Ki
 168                  gki_speederror = gki_speederror+error*time_diff_s;
 169                  // Discard saved error from acceleration as it becomes less relevant after starting
 170                  if (gspeedMeasurements == 28) gki_speederror = 0;
 171                  //Calculate the duty cycle based upon Kp, Ki, and Kd
 172                  duty_cycle_buffer = THREE_FT_DUTY + Kp*error + Ki*gki_speederror + Kd*error/time_diff_s;
 173                  
 174                 //LCD output for debugging
 175                 LCD_ClearDisplay();
 176                 LCD_Position(0,0);
C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 4   

 177                 sprintf(buffer, "%f", duty_cycle_buffer);   
 178                 LCD_PrintString(buffer);
 179                 LCD_Position(1, 1);
 180                 LCD_PrintString("//");
 181                 sprintf(buffer, "%f", error);
 182                 LCD_PrintString(buffer);
 183                  
 184                  //Have in place error checking to ensure duty cycle goes to 1 if negative and caps at a 
 185                  //certain duty cycle to prevent sporadic  behavior
 186                  if (duty_cycle_buffer > 4000){
 187                      duty_cycle_buffer = 1350;   
 188                  }
 189                  if (duty_cycle_buffer <= 0) duty_cycle_buffer = 1;
 190                  if (gTotalTraveled > 2450){
 191                      duty_cycle_buffer = 1;
 192                  }
 193                  duty_cycle = duty_cycle_buffer;
 194          
 195                  
 196          //        //more LCD debugging code
 197          //        LCD_Position(1, 0);
 198          //        //sprintf(buffer, "%f", duty_cycle);
 199          //        LCD_PrintNumber(duty_cycle);
 200          
 201                  MOTOR_PWM_WriteCompare(duty_cycle);
 202              }   
 203          }
 204          */
 205          
 206          CY_ISR(DIR_inter) {
 207   1          gcurr_dir = DIR_PIN_Read();
 208   1          DIR_REG_Write(gcurr_dir);
 209   1      }
 210          
 211          CY_ISR(ON_OFF_inter) {
 212   1          if (gONOFF == 0) {
 213   2              MOTOR_PWM_WriteCompare(1000);
 214   2              gONOFF = 1;
 215   2          }
 216   1          else if (gONOFF == 1) {
 217   2              MOTOR_PWM_WriteCompare(0);
 218   2              gONOFF = 0;
 219   2          }
 220   1      }
 221          
 222          int main()
 223          {
 224   1          //initialize all modules
 225   1          CYGlobalIntEnable;  
 226   1          //HE_TIMER_Start();
 227   1          //HE_ISR_Start();
 228   1          //HE_ISR_SetVector(HE_inter);
 229   1          
 230   1          
 231   1          DIR_ISR_Start();
 232   1          DIR_ISR_SetVector(DIR_inter);
 233   1          ON_OFF_ISR_Start();
 234   1          ON_OFF_ISR_SetVector(ON_OFF_inter);
 235   1          
 236   1          
 237   1          MOTOR_PWM_Start();
 238   1          MOTOR_PWM_CLK_Start();
C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 5   

 239   1          DIR_REG_Write(0);
 240   1          
 241   1          //MOTOR_PWM_WriteCompare(1500);
 242   1          
 243   1          //LINE_COUNTER_Start();  
 244   1          //SEC_TIL_BLACK_TIMER_ISR_Start();
 245   1          //SEC_TIL_BLACK_TIMER_ISR_SetVector(SEC_TIL_BLACK_TIMER_inter);
 246   1          //SEC_TIL_BLACK_TIMER_Start();
 247   1      
 248   1          //UPDATE_STEER_ISR_Start();
 249   1          //UPDATE_STEER_ISR_SetVector(UPDATE_STEER_inter);
 250   1          
 251   1          //STEERING_PWM_Start();
 252   1          //STEERING_PWM_CLK_Start();
 253   1          
 254   1          LCD_Start();
 255   1          LCD_Position(0,0);
 256   1          LCD_PrintString("ELE302 Carlab ");
 257   1          for(;;)
 258   1          {
 259   2          }
 260   1      }
C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 6   

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION DIR_inter (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C000        E     PUSH    ?C?XPAGE1SFR
0013 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0016 C0D0              PUSH    PSW
0018 75D000            MOV     PSW,#00H
001B C000              PUSH    AR0
001D C001              PUSH    AR1
001F C002              PUSH    AR2
0021 C003              PUSH    AR3
0023 C004              PUSH    AR4
0025 C005              PUSH    AR5
0027 C006              PUSH    AR6
0029 C007              PUSH    AR7
                                           ; SOURCE LINE # 206
                                           ; SOURCE LINE # 207
002B 120000      E     LCALL   DIR_PIN_Read
002E 7E00              MOV     R6,#00H
0030 900000      R     MOV     DPTR,#gcurr_dir
0033 EE                MOV     A,R6
0034 F0                MOVX    @DPTR,A
0035 A3                INC     DPTR
0036 EF                MOV     A,R7
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 208
0038 120000      E     LCALL   _DIR_REG_Write
                                           ; SOURCE LINE # 209
003B D007              POP     AR7
003D D006              POP     AR6
003F D005              POP     AR5
0041 D004              POP     AR4
0043 D003              POP     AR3
0045 D002              POP     AR2
0047 D001              POP     AR1
0049 D000              POP     AR0
004B D0D0              POP     PSW
004D D000        E     POP     ?C?XPAGE1SFR
004F D086              POP     DPS
0051 D084              POP     DPL1
0053 D085              POP     DPH1
0055 D082              POP     DPL
0057 D083              POP     DPH
0059 D0F0              POP     B
005B D0E0              POP     ACC
005D 32                RETI    
             ; FUNCTION DIR_inter (END)

             ; FUNCTION ON_OFF_inter (BEGIN)
0000 C0E0              PUSH    ACC
0002 C0F0              PUSH    B
0004 C083              PUSH    DPH
0006 C082              PUSH    DPL
C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 7   

0008 C085              PUSH    DPH1
000A C084              PUSH    DPL1
000C C086              PUSH    DPS
000E 758600            MOV     DPS,#00H
0011 C000        E     PUSH    ?C?XPAGE1SFR
0013 750000      E     MOV     ?C?XPAGE1SFR,#?C?XPAGE1RST
0016 C0D0              PUSH    PSW
0018 75D000            MOV     PSW,#00H
001B C000              PUSH    AR0
001D C001              PUSH    AR1
001F C002              PUSH    AR2
0021 C003              PUSH    AR3
0023 C004              PUSH    AR4
0025 C005              PUSH    AR5
0027 C006              PUSH    AR6
0029 C007              PUSH    AR7
                                           ; SOURCE LINE # 211
                                           ; SOURCE LINE # 212
002B 900000      R     MOV     DPTR,#gONOFF
002E E0                MOVX    A,@DPTR
002F 7002              JNZ     ?C0009
0031 A3                INC     DPTR
0032 E0                MOVX    A,@DPTR
0033         ?C0009:
0033 7011              JNZ     ?C0002
                                           ; SOURCE LINE # 213
0035 7FE8              MOV     R7,#0E8H
0037 7E03              MOV     R6,#03H
0039 120000      E     LCALL   _MOTOR_PWM_WriteCompare
                                           ; SOURCE LINE # 214
003C 900000      R     MOV     DPTR,#gONOFF
003F E4                CLR     A
0040 F0                MOVX    @DPTR,A
0041 A3                INC     DPTR
0042 04                INC     A
0043 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 215
0044 8018              SJMP    ?C0005
0046         ?C0002:
                                           ; SOURCE LINE # 216
0046 900000      R     MOV     DPTR,#gONOFF
0049 E0                MOVX    A,@DPTR
004A 7004              JNZ     ?C0010
004C A3                INC     DPTR
004D E0                MOVX    A,@DPTR
004E 6401              XRL     A,#01H
0050         ?C0010:
0050 700C              JNZ     ?C0005
                                           ; SOURCE LINE # 217
0052 FF                MOV     R7,A
0053 FE                MOV     R6,A
0054 120000      E     LCALL   _MOTOR_PWM_WriteCompare
                                           ; SOURCE LINE # 218
0057 900000      R     MOV     DPTR,#gONOFF
005A E4                CLR     A
005B F0                MOVX    @DPTR,A
005C A3                INC     DPTR
005D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 219
                                           ; SOURCE LINE # 220
005E         ?C0005:
005E D007              POP     AR7
C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 8   

0060 D006              POP     AR6
0062 D005              POP     AR5
0064 D004              POP     AR4
0066 D003              POP     AR3
0068 D002              POP     AR2
006A D001              POP     AR1
006C D000              POP     AR0
006E D0D0              POP     PSW
0070 D000        E     POP     ?C?XPAGE1SFR
0072 D086              POP     DPS
0074 D084              POP     DPL1
0076 D085              POP     DPH1
0078 D082              POP     DPL
007A D083              POP     DPH
007C D0F0              POP     B
007E D0E0              POP     ACC
0080 32                RETI    
             ; FUNCTION ON_OFF_inter (END)

             ; FUNCTION main (BEGIN)
                                           ; SOURCE LINE # 222
                                           ; SOURCE LINE # 223
                                           ; SOURCE LINE # 225
0000 D2AF              SETB    EA
0002 9044F4            MOV     DPTR,#044F4H
0005 74FD              MOV     A,#0FDH
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 231
0008 120000      E     LCALL   DIR_ISR_Start
                                           ; SOURCE LINE # 232
000B 7E00        R     MOV     R6,#HIGH DIR_inter
000D 7F00        R     MOV     R7,#LOW DIR_inter
000F 120000      E     LCALL   _DIR_ISR_SetVector
                                           ; SOURCE LINE # 233
0012 120000      E     LCALL   ON_OFF_ISR_Start
                                           ; SOURCE LINE # 234
0015 7E00        R     MOV     R6,#HIGH ON_OFF_inter
0017 7F00        R     MOV     R7,#LOW ON_OFF_inter
0019 120000      E     LCALL   _ON_OFF_ISR_SetVector
                                           ; SOURCE LINE # 237
001C 120000      E     LCALL   MOTOR_PWM_Start
                                           ; SOURCE LINE # 238
001F 120000      E     LCALL   MOTOR_PWM_CLK_Start
                                           ; SOURCE LINE # 239
0022 E4                CLR     A
0023 FF                MOV     R7,A
0024 120000      E     LCALL   _DIR_REG_Write
                                           ; SOURCE LINE # 254
0027 120000      E     LCALL   LCD_Start
                                           ; SOURCE LINE # 255
002A E4                CLR     A
002B FD                MOV     R5,A
002C FF                MOV     R7,A
002D 120000      E     LCALL   _LCD_Position
                                           ; SOURCE LINE # 256
0030 7BFF              MOV     R3,#0FFH
0032 7A00        R     MOV     R2,#HIGH ?SC_0
0034 7900        R     MOV     R1,#LOW ?SC_0
0036 120000      E     LCALL   _LCD_PrintString
                                           ; SOURCE LINE # 257
0039         ?C0006:
                                           ; SOURCE LINE # 258
C51 COMPILER V9.51   MAIN                                                                  05/02/2015 11:03:01 PAGE 9   

                                           ; SOURCE LINE # 259
0039 80FE              SJMP    ?C0006
003B 22                RET     
             ; FUNCTION main (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    283    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =    101    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
